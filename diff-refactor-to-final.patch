diff --git a/characterClasses/classes.go b/characterClasses/classes.go
deleted file mode 100644
index 06f65cf..0000000
--- a/characterClasses/classes.go
+++ /dev/null
@@ -1,236 +0,0 @@
-package characterClasses
-
-import (
-	"strings"
-
-	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
-)
-
-var (
-	AllWeapons     []domain.WeaponInfo
-	SimpleWeapons  []domain.WeaponInfo
-	MartialWeapons []domain.WeaponInfo
-)
-
-type ClassSkills struct {
-	MaxAllowed int
-	Skills     []string
-	Armor      []string
-	Shields    string
-	Weapons    []domain.WeaponInfo
-	MainHand   string
-	OffHand    string
-}
-
-func InitWeapons(all, simple, martial []domain.WeaponInfo) {
-	AllWeapons = append([]domain.WeaponInfo{}, all...)
-	SimpleWeapons = append([]domain.WeaponInfo{}, simple...)
-	MartialWeapons = append([]domain.WeaponInfo{}, martial...)
-}
-
-func findWeaponByName(name string) domain.WeaponInfo {
-	for _, w := range AllWeapons {
-		if strings.EqualFold(w.Name, name) {
-			return w
-		}
-	}
-	return domain.WeaponInfo{Name: name}
-}
-
-func CombineWeaponSets(sets ...[]domain.WeaponInfo) []domain.WeaponInfo {
-	out := make([]domain.WeaponInfo, 0)
-	for _, s := range sets {
-		out = append(out, s...)
-	}
-	return out
-}
-
-func WithExtraWeapons(base []domain.WeaponInfo, names ...string) []domain.WeaponInfo {
-	out := append([]domain.WeaponInfo{}, base...)
-	for _, n := range names {
-		out = append(out, findWeaponByName(n))
-	}
-	return out
-}
-
-func WeaponsByName(names ...string) []domain.WeaponInfo {
-	out := make([]domain.WeaponInfo, 0, len(names))
-	for _, n := range names {
-		out = append(out, findWeaponByName(n))
-	}
-	return out
-}
-
-var Classes = map[string]ClassSkills{
-	"barbarian": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"animal handling", "athletics", "intimidation", "nature", "perception", "survival",
-		},
-		Armor: []string{
-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
-		},
-		Shields:  "shield",
-		Weapons:  AllWeapons,
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"bard": {
-		MaxAllowed: 3,
-		Skills: []string{
-			"acrobatics", "animal handling", "arcana", "athletics", "deception",
-			"history", "insight", "intimidation", "investigation", "medicine", "nature",
-			"perception", "performance", "persuasion", "religion", "sleight of hand", "stealth", "survival",
-		},
-		Armor: []string{
-			"padded", "leather", "studded leather",
-		},
-		Weapons: WithExtraWeapons(
-			SimpleWeapons,
-			"hand crossbow", "longsword", "rapier", "shortsword",
-		),
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"cleric": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"history", "insight", "medicine", "persuasion", "religion",
-		},
-		Armor: []string{
-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
-		},
-		Shields:  "shield",
-		Weapons:  SimpleWeapons,
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"druid": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"arcana", "animal handling", "insight", "medicine", "nature", "perception", "religion", "survival",
-		},
-		// druids don't wear armor or shields made of metal, fucking animals
-		Armor: []string{
-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
-		},
-		Shields: "shield",
-		Weapons: append(SimpleWeapons,
-			findWeaponByName("club"),
-			findWeaponByName("greatclub"),
-			findWeaponByName("dagger"),
-			findWeaponByName("dart"),
-			findWeaponByName("javelins"),
-			findWeaponByName("maces"),
-			findWeaponByName("quarterstaff"),
-			findWeaponByName("scimitar"),
-			findWeaponByName("sickle"),
-			findWeaponByName("sling"),
-			findWeaponByName("spear"),
-		),
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"fighter": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"acrobatics", "animal handling", "athletics", "history", "insight", "intimidation", "perception", "survival",
-		},
-		Armor: []string{
-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate", "ring mail", "chain mail", "splint", "plate",
-		},
-		Shields:  "shield",
-		Weapons:  AllWeapons,
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"monk": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"acrobatics", "athletics", "history", "insight", "religion", "stealth",
-		},
-		// NO ARMOR
-		Weapons: append(SimpleWeapons,
-			findWeaponByName("shortsword"),
-		),
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"paladin": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"athletics", "insight", "intimidation", "medicine", "persuasion", "religion",
-		},
-		Armor: []string{
-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate", "ring mail", "chain mail", "splint", "plate",
-		},
-		Shields:  "shield",
-		Weapons:  AllWeapons,
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"ranger": {
-		MaxAllowed: 3,
-		Skills: []string{
-			"animal handling", "athletics", "insight", "investigation", "nature", "perception", "stealth", "survival",
-		},
-		Armor: []string{
-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
-		},
-		Shields:  "shield",
-		Weapons:  AllWeapons,
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"rogue": {
-		MaxAllowed: 4,
-		Skills: []string{
-			"acrobatics", "athletics", "deception", "insight", "intimidation", "investigation", "perception", "performance", "persuasion", "sleight of hand", "stealth",
-		},
-		Armor: []string{
-			"padded", "leather", "studded leather",
-		},
-		Weapons: WithExtraWeapons(
-			SimpleWeapons,
-			"hand crossbow", "longsword", "rapier", "shortsword",
-		),
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"sorcerer": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"arcana", "deception", "insight", "intimidation", "persuasion", "religion",
-		},
-		// NO ARMOR
-		Weapons: WeaponsByName(
-			"dagger", "dart", "sling", "quarterstaff", "light crossbow",
-		),
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"warlock": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"arcana", "deception", "history", "intimidation", "investigation", "nature", "religion",
-		},
-		Armor: []string{
-			"padded", "leather", "studded leather",
-		},
-		Weapons:  SimpleWeapons,
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-	"wizard": {
-		MaxAllowed: 2,
-		Skills: []string{
-			"arcana", "history", "insight", "investigation", "medicine", "religion",
-		},
-		// NO ARMOR
-		Weapons: WeaponsByName(
-			"dagger", "dart", "sling", "quarterstaff", "light crossbow",
-		),
-		MainHand: "main hand",
-		OffHand:  "off hand",
-	},
-}
diff --git a/data/characters.json b/data/characters.json
index a801f76..4f80a63 100644
--- a/data/characters.json
+++ b/data/characters.json
@@ -1,324 +1,24 @@
 [
   {
-    "Name": "Gandalf",
-    "Race": "human",
-    "Background": "acolyte",
-    "Class": "wizard",
-    "Level": 20,
-    "Proficiency": 6,
-    "Stats": {
-      "Str": 9,
-      "StrMod": -1,
-      "Dex": 11,
-      "DexMod": 0,
-      "Con": 13,
-      "ConMod": 1,
-      "Intel": 15,
-      "IntelMod": 2,
-      "Wis": 16,
-      "WisMod": 3,
-      "Cha": 14,
-      "ChaMod": 2
-    },
-    "Skills": {
-      "MaxAllowed": 2,
-      "Skills": [
-        "arcana",
-        "history",
-        "insight",
-        "religion"
-      ],
-      "Armor": null,
-      "Shields": "",
-      "Weapons": [
-        {
-          "Name": "dagger",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        },
-        {
-          "Name": "dart",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        },
-        {
-          "Name": "sling",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        },
-        {
-          "Name": "quarterstaff",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        },
-        {
-          "Name": "light crossbow",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        }
-      ],
-      "MainHand": "main hand",
-      "OffHand": "off hand"
-    },
-    "Equipment": {
-      "Weapon": {
-        "main hand": "",
-        "off hand": ""
-      },
-      "Armor": "",
-      "Shield": ""
-    },
-    "Spellcasting": {
-      "CantripsKnown": 5,
-      "SpellsKnown": 0,
-      "CanCast": true,
-      "CasterType": "full",
-      "learned_spells": [],
-      "prepared_spells": [
-        "burning hands"
-      ],
-      "slots": {
-        "1": 4,
-        "2": 3,
-        "3": 3,
-        "4": 3,
-        "5": 3,
-        "6": 2,
-        "7": 2,
-        "8": 1,
-        "9": 1
-      },
-      "maxslots": {
-        "1": 4,
-        "2": 3,
-        "3": 3,
-        "4": 3,
-        "5": 3,
-        "6": 2,
-        "7": 2,
-        "8": 1,
-        "9": 1
-      },
-      "PreparedMode": true,
-      "LearnedMode": false,
-      "Ability": "intelligence",
-      "SpellSaveDC": 16,
-      "SpellAttackBonus": 8
-    },
-    "ArmorClass": 10,
-    "InitiativeBonus": 0,
-    "PassivePerception": 13
-  },
-  {
-    "Name": "Galadriel",
-    "Race": "high elf",
-    "Background": "acolyte",
-    "Class": "sorcerer",
-    "Level": 20,
-    "Proficiency": 6,
-    "Stats": {
-      "Str": 8,
-      "StrMod": -1,
-      "Dex": 10,
-      "DexMod": 0,
-      "Con": 12,
-      "ConMod": 1,
-      "Intel": 15,
-      "IntelMod": 2,
-      "Wis": 14,
-      "WisMod": 2,
-      "Cha": 13,
-      "ChaMod": 1
-    },
-    "Skills": {
-      "MaxAllowed": 2,
-      "Skills": [
-        "arcana",
-        "deception",
-        "insight",
-        "religion"
-      ],
-      "Armor": null,
-      "Shields": "",
-      "Weapons": [
-        {
-          "Name": "dagger",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        },
-        {
-          "Name": "dart",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        },
-        {
-          "Name": "sling",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        },
-        {
-          "Name": "quarterstaff",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        },
-        {
-          "Name": "light crossbow",
-          "Category": "",
-          "Range": 0,
-          "TwoHanded": false
-        }
-      ],
-      "MainHand": "main hand",
-      "OffHand": "off hand"
-    },
-    "Equipment": {
-      "Weapon": {
-        "main hand": "",
-        "off hand": ""
-      },
-      "Armor": "",
-      "Shield": ""
-    },
-    "Spellcasting": {
-      "CantripsKnown": 5,
-      "SpellsKnown": 0,
-      "CanCast": true,
-      "CasterType": "full",
-      "learned_spells": [
-        "false life"
-      ],
-      "prepared_spells": [],
-      "slots": {
-        "1": 4,
-        "2": 3,
-        "3": 3,
-        "4": 3,
-        "5": 3,
-        "6": 2,
-        "7": 2,
-        "8": 1,
-        "9": 1
-      },
-      "maxslots": {
-        "1": 4,
-        "2": 3,
-        "3": 3,
-        "4": 3,
-        "5": 3,
-        "6": 2,
-        "7": 2,
-        "8": 1,
-        "9": 1
-      },
-      "PreparedMode": false,
-      "LearnedMode": true,
-      "Ability": "charisma",
-      "SpellSaveDC": 15,
-      "SpellAttackBonus": 7
-    },
-    "ArmorClass": 10,
-    "InitiativeBonus": 0,
-    "PassivePerception": 12
-  },
-  {
-    "Name": "Anakin Skywalker",
-    "Race": "human",
-    "Background": "acolyte",
-    "Class": "warlock",
-    "Level": 20,
-    "Proficiency": 6,
-    "Stats": {
-      "Str": 13,
-      "StrMod": 1,
-      "Dex": 9,
-      "DexMod": -1,
-      "Con": 15,
-      "ConMod": 2,
-      "Intel": 14,
-      "IntelMod": 2,
-      "Wis": 11,
-      "WisMod": 0,
-      "Cha": 16,
-      "ChaMod": 3
-    },
-    "Skills": {
-      "MaxAllowed": 2,
-      "Skills": [
-        "arcana",
-        "deception",
-        "insight",
-        "religion"
-      ],
-      "Armor": [
-        "padded",
-        "leather",
-        "studded leather"
-      ],
-      "Shields": "",
-      "Weapons": null,
-      "MainHand": "main hand",
-      "OffHand": "off hand"
-    },
-    "Equipment": {
-      "Weapon": {
-        "main hand": "",
-        "off hand": "dagger"
-      },
-      "Armor": "",
-      "Shield": ""
-    },
-    "Spellcasting": {
-      "CantripsKnown": 4,
-      "SpellsKnown": 0,
-      "CanCast": true,
-      "CasterType": "pact",
-      "learned_spells": [],
-      "prepared_spells": [],
-      "slots": {
-        "5": 4
-      },
-      "maxslots": {
-        "5": 4
-      },
-      "PreparedMode": false,
-      "LearnedMode": false,
-      "Ability": "charisma",
-      "SpellSaveDC": 17,
-      "SpellAttackBonus": 9
-    },
-    "ArmorClass": 9,
-    "InitiativeBonus": -1,
-    "PassivePerception": 10
-  },
-  {
-    "Name": "Kaelen Swiftstep",
-    "Race": "human",
+    "Name": "Thorga Stonehand",
+    "Race": "hill dwarf",
     "Background": "acolyte",
     "Class": "rogue",
     "Level": 1,
     "Proficiency": 2,
     "Stats": {
-      "Str": 11,
-      "StrMod": 0,
-      "Dex": 16,
-      "DexMod": 3,
-      "Con": 15,
-      "ConMod": 2,
-      "Intel": 13,
-      "IntelMod": 1,
+      "Str": 15,
+      "StrMod": 2,
+      "Dex": 12,
+      "DexMod": 1,
+      "Con": 16,
+      "ConMod": 3,
+      "Intel": 8,
+      "IntelMod": -1,
       "Wis": 14,
       "WisMod": 2,
-      "Cha": 9,
-      "ChaMod": -1
+      "Cha": 10,
+      "ChaMod": 0
     },
     "Skills": {
       "MaxAllowed": 4,
@@ -328,7 +28,8 @@
         "deception",
         "insight",
         "insight",
-        "religion"
+        "religion",
+        "history"
       ],
       "Armor": [
         "padded",
@@ -370,7 +71,7 @@
         "main hand": "",
         "off hand": ""
       },
-      "Armor": "leather armor",
+      "Armor": "",
       "Shield": ""
     },
     "Spellcasting": {
@@ -388,82 +89,7 @@
       "SpellSaveDC": 0,
       "SpellAttackBonus": 0
     },
-    "ArmorClass": 14,
-    "InitiativeBonus": 3,
-    "PassivePerception": 12
-  },
-  {
-    "Name": "Thorga Stonehand",
-    "Race": "hill dwarf",
-    "Background": "acolyte",
-    "Class": "fighter",
-    "Level": 1,
-    "Proficiency": 2,
-    "Stats": {
-      "Str": 15,
-      "StrMod": 2,
-      "Dex": 12,
-      "DexMod": 1,
-      "Con": 16,
-      "ConMod": 3,
-      "Intel": 8,
-      "IntelMod": -1,
-      "Wis": 14,
-      "WisMod": 2,
-      "Cha": 10,
-      "ChaMod": 0
-    },
-    "Skills": {
-      "MaxAllowed": 2,
-      "Skills": [
-        "acrobatics",
-        "animal handling",
-        "insight",
-        "religion"
-      ],
-      "Armor": [
-        "padded",
-        "leather",
-        "studded leather",
-        "hide",
-        "chain shirt",
-        "scale mail",
-        "breast plate",
-        "half plate",
-        "ring mail",
-        "chain mail",
-        "splint",
-        "plate"
-      ],
-      "Shields": "shield",
-      "Weapons": null,
-      "MainHand": "main hand",
-      "OffHand": "off hand"
-    },
-    "Equipment": {
-      "Weapon": {
-        "main hand": "",
-        "off hand": ""
-      },
-      "Armor": "scale mail",
-      "Shield": "shield"
-    },
-    "Spellcasting": {
-      "CantripsKnown": 0,
-      "SpellsKnown": 0,
-      "CanCast": false,
-      "CasterType": "",
-      "learned_spells": [],
-      "prepared_spells": [],
-      "slots": {},
-      "maxslots": {},
-      "PreparedMode": false,
-      "LearnedMode": false,
-      "Ability": "",
-      "SpellSaveDC": 0,
-      "SpellAttackBonus": 0
-    },
-    "ArmorClass": 17,
+    "ArmorClass": 11,
     "InitiativeBonus": 1,
     "PassivePerception": 12
   },
@@ -494,7 +120,8 @@
         "animal handling",
         "athletics",
         "insight",
-        "religion"
+        "religion",
+        "intimidation"
       ],
       "Armor": [
         "padded",
@@ -507,7 +134,7 @@
         "half plate"
       ],
       "Shields": "shield",
-      "Weapons": null,
+      "Weapons": [],
       "MainHand": "main hand",
       "OffHand": "off hand"
     },
@@ -537,305 +164,5 @@
     "ArmorClass": 14,
     "InitiativeBonus": 2,
     "PassivePerception": 11
-  },
-  {
-    "Name": "Gorrak Bearhide",
-    "Race": "human",
-    "Background": "acolyte",
-    "Class": "barbarian",
-    "Level": 1,
-    "Proficiency": 2,
-    "Stats": {
-      "Str": 16,
-      "StrMod": 3,
-      "Dex": 14,
-      "DexMod": 2,
-      "Con": 15,
-      "ConMod": 2,
-      "Intel": 9,
-      "IntelMod": -1,
-      "Wis": 13,
-      "WisMod": 1,
-      "Cha": 11,
-      "ChaMod": 0
-    },
-    "Skills": {
-      "MaxAllowed": 2,
-      "Skills": [
-        "animal handling",
-        "athletics",
-        "insight",
-        "religion"
-      ],
-      "Armor": [
-        "padded",
-        "leather",
-        "studded leather",
-        "hide",
-        "chain shirt",
-        "scale mail",
-        "breast plate",
-        "half plate"
-      ],
-      "Shields": "shield",
-      "Weapons": null,
-      "MainHand": "main hand",
-      "OffHand": "off hand"
-    },
-    "Equipment": {
-      "Weapon": {
-        "main hand": "",
-        "off hand": ""
-      },
-      "Armor": "",
-      "Shield": "shield"
-    },
-    "Spellcasting": {
-      "CantripsKnown": 0,
-      "SpellsKnown": 0,
-      "CanCast": false,
-      "CasterType": "",
-      "learned_spells": [],
-      "prepared_spells": [],
-      "slots": {},
-      "maxslots": {},
-      "PreparedMode": false,
-      "LearnedMode": false,
-      "Ability": "",
-      "SpellSaveDC": 0,
-      "SpellAttackBonus": 0
-    },
-    "ArmorClass": 16,
-    "InitiativeBonus": 2,
-    "PassivePerception": 11
-  },
-  {
-    "Name": "Brynja Axebreaker",
-    "Race": "human",
-    "Background": "acolyte",
-    "Class": "barbarian",
-    "Level": 1,
-    "Proficiency": 2,
-    "Stats": {
-      "Str": 16,
-      "StrMod": 3,
-      "Dex": 14,
-      "DexMod": 2,
-      "Con": 15,
-      "ConMod": 2,
-      "Intel": 9,
-      "IntelMod": -1,
-      "Wis": 13,
-      "WisMod": 1,
-      "Cha": 11,
-      "ChaMod": 0
-    },
-    "Skills": {
-      "MaxAllowed": 2,
-      "Skills": [
-        "animal handling",
-        "athletics",
-        "insight",
-        "religion"
-      ],
-      "Armor": [
-        "padded",
-        "leather",
-        "studded leather",
-        "hide",
-        "chain shirt",
-        "scale mail",
-        "breast plate",
-        "half plate"
-      ],
-      "Shields": "shield",
-      "Weapons": null,
-      "MainHand": "main hand",
-      "OffHand": "off hand"
-    },
-    "Equipment": {
-      "Weapon": {
-        "main hand": "",
-        "off hand": ""
-      },
-      "Armor": "",
-      "Shield": "shield"
-    },
-    "Spellcasting": {
-      "CantripsKnown": 0,
-      "SpellsKnown": 0,
-      "CanCast": false,
-      "CasterType": "",
-      "learned_spells": [],
-      "prepared_spells": [],
-      "slots": {},
-      "maxslots": {},
-      "PreparedMode": false,
-      "LearnedMode": false,
-      "Ability": "",
-      "SpellSaveDC": 0,
-      "SpellAttackBonus": 0
-    },
-    "ArmorClass": 16,
-    "InitiativeBonus": 2,
-    "PassivePerception": 11
-  },
-  {
-    "Name": "Qui-Gon Jinn",
-    "Race": "human",
-    "Background": "acolyte",
-    "Class": "cleric",
-    "Level": 10,
-    "Proficiency": 4,
-    "Stats": {
-      "Str": 15,
-      "StrMod": 2,
-      "Dex": 9,
-      "DexMod": -1,
-      "Con": 11,
-      "ConMod": 0,
-      "Intel": 14,
-      "IntelMod": 2,
-      "Wis": 16,
-      "WisMod": 3,
-      "Cha": 13,
-      "ChaMod": 1
-    },
-    "Skills": {
-      "MaxAllowed": 2,
-      "Skills": [
-        "history",
-        "insight",
-        "insight",
-        "religion"
-      ],
-      "Armor": [
-        "padded",
-        "leather",
-        "studded leather",
-        "hide",
-        "chain shirt",
-        "scale mail",
-        "breast plate",
-        "half plate"
-      ],
-      "Shields": "shield",
-      "Weapons": null,
-      "MainHand": "main hand",
-      "OffHand": "off hand"
-    },
-    "Equipment": {
-      "Weapon": {
-        "main hand": "",
-        "off hand": ""
-      },
-      "Armor": "",
-      "Shield": ""
-    },
-    "Spellcasting": {
-      "CantripsKnown": 5,
-      "SpellsKnown": 0,
-      "CanCast": true,
-      "CasterType": "full",
-      "learned_spells": [],
-      "prepared_spells": [],
-      "slots": {
-        "1": 4,
-        "2": 3,
-        "3": 3,
-        "4": 3,
-        "5": 2
-      },
-      "maxslots": {
-        "1": 4,
-        "2": 3,
-        "3": 3,
-        "4": 3,
-        "5": 2
-      },
-      "PreparedMode": false,
-      "LearnedMode": false,
-      "Ability": "wisdom",
-      "SpellSaveDC": 15,
-      "SpellAttackBonus": 7
-    },
-    "ArmorClass": 9,
-    "InitiativeBonus": -1,
-    "PassivePerception": 13
-  },
-  {
-    "Name": "Branric Ironwall",
-    "Race": "human",
-    "Background": "acolyte",
-    "Class": "paladin",
-    "Level": 1,
-    "Proficiency": 2,
-    "Stats": {
-      "Str": 16,
-      "StrMod": 3,
-      "Dex": 9,
-      "DexMod": -1,
-      "Con": 15,
-      "ConMod": 2,
-      "Intel": 11,
-      "IntelMod": 0,
-      "Wis": 13,
-      "WisMod": 1,
-      "Cha": 14,
-      "ChaMod": 2
-    },
-    "Skills": {
-      "MaxAllowed": 2,
-      "Skills": [
-        "athletics",
-        "insight",
-        "insight",
-        "religion"
-      ],
-      "Armor": [
-        "padded",
-        "leather",
-        "studded leather",
-        "hide",
-        "chain shirt",
-        "scale mail",
-        "breast plate",
-        "half plate",
-        "ring mail",
-        "chain mail",
-        "splint",
-        "plate"
-      ],
-      "Shields": "shield",
-      "Weapons": null,
-      "MainHand": "main hand",
-      "OffHand": "off hand"
-    },
-    "Equipment": {
-      "Weapon": {
-        "main hand": "",
-        "off hand": ""
-      },
-      "Armor": "plate armor",
-      "Shield": "shield"
-    },
-    "Spellcasting": {
-      "CantripsKnown": 0,
-      "SpellsKnown": 0,
-      "CanCast": false,
-      "CasterType": "half",
-      "learned_spells": [],
-      "prepared_spells": [],
-      "slots": {},
-      "maxslots": {},
-      "PreparedMode": false,
-      "LearnedMode": false,
-      "Ability": "",
-      "SpellSaveDC": 0,
-      "SpellAttackBonus": 0
-    },
-    "ArmorClass": 20,
-    "InitiativeBonus": -1,
-    "PassivePerception": 11
   }
 ]
\ No newline at end of file
diff --git a/domain/armor_test.go b/domain/armor_test.go
new file mode 100644
index 0000000..c6a3161
--- /dev/null
+++ b/domain/armor_test.go
@@ -0,0 +1,43 @@
+package domain_test
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestArmorClass_NoArmor(t *testing.T) {
+	c := &domain.Character{
+		Class: "fighter",
+		Stats: domain.Stats{DexMod: 2},
+		Equipment: domain.Equipment{
+			Armor:  "",
+			Shield: "",
+		},
+	}
+
+	got := c.CalculateArmorClass()
+	want := 12 // 10 + Dex(2)
+
+	if got != want {
+		t.Errorf("AC: want %d got %d", want, got)
+	}
+}
+
+func TestArmorClass_WithShield(t *testing.T) {
+	c := &domain.Character{
+		Class: "fighter",
+		Stats: domain.Stats{DexMod: 2},
+		Equipment: domain.Equipment{
+			Armor:  "",
+			Shield: "shield",
+		},
+	}
+
+	got := c.CalculateArmorClass()
+	want := 14 // 10 + Dex(2) + 2 shield
+
+	if got != want {
+		t.Errorf("AC: want %d got %d", want, got)
+	}
+}
diff --git a/domain/character.go b/domain/character.go
index ab8e217..b5b6564 100644
--- a/domain/character.go
+++ b/domain/character.go
@@ -1,17 +1,6 @@
 package domain
 
-var SpellcastingType = map[string]string{
-	"bard":     "full",
-	"cleric":   "full",
-	"druid":    "full",
-	"sorcerer": "full",
-	"wizard":   "full",
-
-	"paladin": "half",
-	"ranger":  "half",
-
-	"warlock": "pact",
-}
+import "strings"
 
 type Character struct {
 	Name              string
@@ -29,75 +18,95 @@ type Character struct {
 	PassivePerception int
 }
 
-type ClassLoadout struct {
-	MaxAllowed int
-	Skills     []string
-	Armor      []string
-	Shields    string
-	Weapons    []WeaponInfo
-	MainHand   string
-	OffHand    string
-}
-
-type Stats struct {
-	Str    int
-	StrMod int
-
-	Dex    int
-	DexMod int
-
-	Con    int
-	ConMod int
-
-	Intel    int
-	IntelMod int
-
-	Wis    int
-	WisMod int
-
-	Cha    int
-	ChaMod int
-}
-
-type Equipment struct {
-	Weapon map[string]string
-	Armor  string
-	Shield string
-}
-
-type Spellcasting struct {
-	CantripsKnown    int
-	SpellsKnown      int
-	CanCast          bool
-	CasterType       string
-	LearnedSpells    []string    `json:"learned_spells"`
-	PreparedSpells   []string    `json:"prepared_spells"`
-	Slots            map[int]int `json:"slots"`
-	MaxSlots         map[int]int `json:"maxslots"`
-	PreparedMode     bool
-	LearnedMode      bool
-	Ability          string
-	SpellSaveDC      int
-	SpellAttackBonus int
-}
-
-type SpellInfo struct {
-	Name   string `json:"name"`
-	Level  int    `json:"level"`
-	School string `json:"school"`
-	Range  string `json:"range"`
+func (c *Character) UpdateProficiency() {
+	switch {
+	case c.Level >= 17:
+		c.Proficiency = 6
+	case c.Level >= 13:
+		c.Proficiency = 5
+	case c.Level >= 9:
+		c.Proficiency = 4
+	case c.Level >= 5:
+		c.Proficiency = 3
+	default:
+		c.Proficiency = 2
+	}
+
+	c.Stats.StrMod = abilityModifier(c.Stats.Str)
+	c.Stats.DexMod = abilityModifier(c.Stats.Dex)
+	c.Stats.ConMod = abilityModifier(c.Stats.Con)
+	c.Stats.IntelMod = abilityModifier(c.Stats.Intel)
+	c.Stats.WisMod = abilityModifier(c.Stats.Wis)
+	c.Stats.ChaMod = abilityModifier(c.Stats.Cha)
 }
 
-type WeaponInfo struct {
-	Name      string
-	Category  string
-	Range     int
-	TwoHanded bool
+func (c *Character) ApplyRacialBonuses() {
+	race := strings.ToLower(strings.ReplaceAll(c.Race, " ", "-"))
+	switch race {
+	case "dwarf":
+		c.Stats.Con += 2
+
+	case "hill-dwarf":
+		c.Stats.Con += 2
+		c.Stats.Wis += 1
+
+	case "elf":
+		c.Stats.Dex += 2
+
+	case "halfling", "stout-halfling":
+		c.Stats.Dex += 2
+
+	case "lightfoot-halfling":
+		c.Stats.Dex += 2
+		c.Stats.Cha++
+
+	case "human":
+		c.Stats.Str++
+		c.Stats.Dex++
+		c.Stats.Con++
+		c.Stats.Intel++
+		c.Stats.Wis++
+		c.Stats.Cha++
+
+	case "dragonborn":
+		c.Stats.Str += 2
+		c.Stats.Cha++
+
+	case "gnome":
+		c.Stats.Intel += 2
+
+	// TODO: half-eelves get to choose which stats to increase besides the rizz, for now dex and wis as defaults
+	case "half-elf":
+		c.Stats.Cha += 2
+		c.Stats.Dex++
+		c.Stats.Wis++
+
+	case "half-orc":
+		c.Stats.Str += 2
+		c.Stats.Con++
+
+	case "tiefling":
+		c.Stats.Cha += 2
+		c.Stats.Intel++
+	}
+
+	c.UpdateProficiency()
 }
 
-type ArmorInfo struct {
-	Name     string
-	BaseAC   int
-	DexBonus bool
-	MaxBonus int
+func SanitizeLocalKey(name string) string {
+	key := strings.ToLower(name)
+	key = strings.ReplaceAll(key, "'", "")
+	key = strings.ReplaceAll(key, "â€™", "")
+	key = strings.ReplaceAll(key, "(", "")
+	key = strings.ReplaceAll(key, ")", "")
+	key = strings.ReplaceAll(key, ",", "")
+	key = strings.ReplaceAll(key, "/", "-")
+	key = strings.ReplaceAll(key, ":", "")
+	key = strings.ReplaceAll(key, ".", "")
+	key = strings.ReplaceAll(key, " ", "-")
+	key = strings.ReplaceAll(key, " ", "-")
+	key = strings.TrimSuffix(key, "-armor")
+	key = strings.TrimSuffix(key, " armor")
+	key = strings.TrimSpace(key)
+	return key
 }
diff --git a/domain/character_new.go b/domain/character_new.go
new file mode 100644
index 0000000..fb645d5
--- /dev/null
+++ b/domain/character_new.go
@@ -0,0 +1,36 @@
+package domain
+
+import "fmt"
+
+func NewCharacter(name, race, background, class string, level int, stats Stats) (*Character, error) {
+	if name == "" {
+		return nil, fmt.Errorf("character name is required")
+	}
+	if race == "" {
+		return nil, fmt.Errorf("character race is required")
+	}
+	if class == "" {
+		return nil, fmt.Errorf("character class is required")
+	}
+	if level <= 0 {
+		return nil, fmt.Errorf("character level must be > 0")
+	}
+
+	c := &Character{
+		Name:       name,
+		Race:       race,
+		Background: background,
+		Class:      class,
+		Level:      level,
+		Stats:      stats,
+		Equipment: Equipment{
+			Weapon: map[string]string{"main hand": "", "off hand": ""},
+			Armor:  "",
+			Shield: "",
+		},
+	}
+
+	c.ApplyRacialBonuses()
+
+	return c, nil
+}
diff --git a/domain/character_proficiency_test.go b/domain/character_proficiency_test.go
new file mode 100644
index 0000000..eab8f5f
--- /dev/null
+++ b/domain/character_proficiency_test.go
@@ -0,0 +1,31 @@
+package domain
+
+import "testing"
+
+func TestUpdateProficiency(t *testing.T) {
+	tests := []struct {
+		level    int
+		wantProf int
+	}{
+		{1, 2},
+		{4, 2},
+		{5, 3},
+		{8, 3},
+		{9, 4},
+		{12, 4},
+		{13, 5},
+		{16, 5},
+		{17, 6},
+		{20, 6},
+	}
+
+	for _, tt := range tests {
+		c := &Character{Level: tt.level}
+		c.UpdateProficiency()
+
+		if c.Proficiency != tt.wantProf {
+			t.Errorf("Level %d: expected prof %d, got %d",
+				tt.level, tt.wantProf, c.Proficiency)
+		}
+	}
+}
diff --git a/domain/character_race_test.go b/domain/character_race_test.go
new file mode 100644
index 0000000..73f4ed8
--- /dev/null
+++ b/domain/character_race_test.go
@@ -0,0 +1,30 @@
+package domain_test
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestApplyRacialSkillProficiencies_Dwarf(t *testing.T) {
+	c := &domain.Character{
+		Race: "dwarf",
+		Skills: domain.ClassLoadout{
+			Skills: []string{"insight", "religion"},
+		},
+	}
+
+	c.ApplyRacialSkillProficiencies()
+
+	want := []string{"insight", "religion", "history"}
+
+	if len(c.Skills.Skills) != len(want) {
+		t.Fatalf("expected %v skills, got %v", want, c.Skills.Skills)
+	}
+
+	for i, v := range want {
+		if c.Skills.Skills[i] != v {
+			t.Errorf("expected %s, got %s", v, c.Skills.Skills[i])
+		}
+	}
+}
diff --git a/domain/class/classes.go b/domain/class/classes.go
new file mode 100644
index 0000000..23c6347
--- /dev/null
+++ b/domain/class/classes.go
@@ -0,0 +1,265 @@
+package class
+
+import (
+	"strings"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+type ClassRepository struct {
+	all     []domain.WeaponInfo
+	simple  []domain.WeaponInfo
+	martial []domain.WeaponInfo
+
+	classes map[string]ClassSkills
+}
+
+type ClassSkills struct {
+	MaxAllowed int
+	Skills     []string
+	Armor      []string
+	Shields    string
+	Weapons    []domain.WeaponInfo
+	MainHand   string
+	OffHand    string
+}
+
+func NewClassRepository(all, simple, martial []domain.WeaponInfo) *ClassRepository {
+	cr := &ClassRepository{
+		all:     append([]domain.WeaponInfo{}, all...),
+		simple:  append([]domain.WeaponInfo{}, simple...),
+		martial: append([]domain.WeaponInfo{}, martial...),
+	}
+	cr.classes = cr.buildClasses()
+	return cr
+}
+
+func (r *ClassRepository) Get(className string) (ClassSkills, bool) {
+	key := strings.ToLower(strings.TrimSpace(className))
+	cs, ok := r.classes[key]
+	return cs, ok
+}
+
+func (r *ClassRepository) findByName(name string) (domain.WeaponInfo, bool) {
+	lo := strings.ToLower(strings.TrimSpace(name))
+	for _, w := range r.all {
+		if strings.EqualFold(strings.TrimSpace(w.Name), lo) {
+			return w, true
+		}
+	}
+	return domain.WeaponInfo{Name: name}, false
+}
+
+func (r *ClassRepository) CombineWeaponSets(sets ...[]domain.WeaponInfo) []domain.WeaponInfo {
+	out := make([]domain.WeaponInfo, 0)
+	for _, s := range sets {
+		out = append(out, s...)
+	}
+	return out
+}
+
+func (r *ClassRepository) withExtra(base []domain.WeaponInfo, names ...string) []domain.WeaponInfo {
+	out := append([]domain.WeaponInfo{}, base...)
+	for _, n := range names {
+		if w, ok := r.findByName(n); ok {
+			out = append(out, w)
+		} else {
+			out = append(out, domain.WeaponInfo{Name: n})
+		}
+	}
+	return out
+}
+
+func (r *ClassRepository) WeaponsByName(names ...string) []domain.WeaponInfo {
+	out := make([]domain.WeaponInfo, 0, len(names))
+	for _, n := range names {
+		if w, ok := r.findByName(n); ok {
+			out = append(out, w)
+		} else {
+			out = append(out, domain.WeaponInfo{Name: n})
+		}
+	}
+	return out
+}
+
+func (r *ClassRepository) weaponOrFallback(name string) domain.WeaponInfo {
+	if w, ok := r.findByName(name); ok {
+		return w
+	}
+	return domain.WeaponInfo{Name: name}
+}
+
+func (r *ClassRepository) buildClasses() map[string]ClassSkills {
+	return map[string]ClassSkills{
+		"barbarian": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"animal handling", "athletics", "intimidation", "nature", "perception", "survival",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
+			},
+			Shields:  "shield",
+			Weapons:  r.all,
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"bard": {
+			MaxAllowed: 3,
+			Skills: []string{
+				"acrobatics", "animal handling", "arcana", "athletics", "deception",
+				"history", "insight", "intimidation", "investigation", "medicine", "nature",
+				"perception", "performance", "persuasion", "religion", "sleight of hand", "stealth", "survival",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather",
+			},
+			Weapons: r.withExtra(
+				r.simple,
+				"hand crossbow", "longsword", "rapier", "shortsword",
+			),
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"cleric": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"history", "insight", "medicine", "persuasion", "religion",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
+			},
+			Shields:  "shield",
+			Weapons:  r.simple,
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"druid": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"arcana", "animal handling", "insight", "medicine", "nature", "perception", "religion", "survival",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
+			},
+			Shields: "shield",
+			Weapons: append(r.simple,
+				r.weaponOrFallback("club"),
+				r.weaponOrFallback("greatclub"),
+				r.weaponOrFallback("dagger"),
+				r.weaponOrFallback("dart"),
+				r.weaponOrFallback("javelins"),
+				r.weaponOrFallback("maces"),
+				r.weaponOrFallback("quarterstaff"),
+				r.weaponOrFallback("scimitar"),
+				r.weaponOrFallback("sickle"),
+				r.weaponOrFallback("sling"),
+				r.weaponOrFallback("spear"),
+			),
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"fighter": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"acrobatics", "animal handling", "athletics", "history", "insight", "intimidation", "perception", "survival",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate", "ring mail", "chain mail", "splint", "plate",
+			},
+			Shields:  "shield",
+			Weapons:  r.simple,
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"monk": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"acrobatics", "athletics", "history", "insight", "religion", "stealth",
+			},
+			// NO ARMOR
+			Weapons: append(r.simple,
+				r.weaponOrFallback("shortsword"),
+			),
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"paladin": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"athletics", "insight", "intimidation", "medicine", "persuasion", "religion",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate", "ring mail", "chain mail", "splint", "plate",
+			},
+			Shields:  "shield",
+			Weapons:  r.all,
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"ranger": {
+			MaxAllowed: 3,
+			Skills: []string{
+				"animal handling", "athletics", "insight", "investigation", "nature", "perception", "stealth", "survival",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
+			},
+			Shields:  "shield",
+			Weapons:  r.all,
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"rogue": {
+			MaxAllowed: 4,
+			Skills: []string{
+				"acrobatics", "athletics", "deception", "insight", "intimidation", "investigation", "perception", "performance", "persuasion", "sleight of hand", "stealth",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather",
+			},
+			Weapons: r.withExtra(
+				r.simple,
+				"hand crossbow", "longsword", "rapier", "shortsword",
+			),
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"sorcerer": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"arcana", "deception", "insight", "intimidation", "persuasion", "religion",
+			},
+			// NO ARMOR
+			Weapons: r.WeaponsByName(
+				"dagger", "dart", "sling", "quarterstaff", "light crossbow",
+			),
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"warlock": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"arcana", "deception", "history", "intimidation", "investigation", "nature", "religion",
+			},
+			Armor: []string{
+				"padded", "leather", "studded leather",
+			},
+			Weapons:  r.simple,
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+		"wizard": {
+			MaxAllowed: 2,
+			Skills: []string{
+				"arcana", "history", "insight", "investigation", "medicine", "religion",
+			},
+			// NO ARMOR
+			Weapons: r.WeaponsByName(
+				"dagger", "dart", "sling", "quarterstaff", "light crossbow",
+			),
+			MainHand: "main hand",
+			OffHand:  "off hand",
+		},
+	}
+}
diff --git a/domain/class/classes_test.go b/domain/class/classes_test.go
new file mode 100644
index 0000000..bdff1f3
--- /dev/null
+++ b/domain/class/classes_test.go
@@ -0,0 +1,102 @@
+package class
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func fakeWeapons() (all, simple, martial []domain.WeaponInfo) {
+	all = []domain.WeaponInfo{
+		{Name: "dagger"},
+		{Name: "longsword"},
+		{Name: "hand crossbow"},
+	}
+
+	simple = []domain.WeaponInfo{
+		{Name: "dagger"},
+	}
+
+	martial = []domain.WeaponInfo{
+		{Name: "longsword"},
+	}
+
+	return
+}
+
+func TestClassRepository_Get(t *testing.T) {
+	all, simple, martial := fakeWeapons()
+	repo := NewClassRepository(all, simple, martial)
+
+	cs, ok := repo.Get(" Bard ")
+	if !ok {
+		t.Fatalf("expected bard to exist")
+	}
+
+	if cs.MaxAllowed != 3 {
+		t.Errorf("expected bard MaxAllowed=3, got %d", cs.MaxAllowed)
+	}
+	if len(cs.Skills) == 0 {
+		t.Errorf("expected bard to have skills")
+	}
+}
+
+func TestClassRepository_findByName(t *testing.T) {
+	all, simple, martial := fakeWeapons()
+	repo := NewClassRepository(all, simple, martial)
+
+	w, ok := repo.FindByName("dagger")
+	if !ok || w.Name != "dagger" {
+		t.Errorf("expected to find dagger")
+	}
+
+	w2, ok2 := repo.FindByName("nonexistent")
+	if ok2 || w2.Name != "nonexistent" {
+		t.Errorf("expected fallback weapon")
+	}
+}
+
+func (r *ClassRepository) FindByName(name string) (domain.WeaponInfo, bool) {
+	return r.findByName(name)
+}
+
+func TestClassRepository_WithExtra(t *testing.T) {
+	all, simple, martial := fakeWeapons()
+	repo := NewClassRepository(all, simple, martial)
+
+	result := repo.withExtra(simple, "longsword", "unknown")
+
+	if len(result) != 3 {
+		t.Fatalf("expected 3 weapons, got %d", len(result))
+	}
+	if result[1].Name != "longsword" {
+		t.Errorf("expected longsword to be added")
+	}
+	if result[2].Name != "unknown" {
+		t.Errorf("expected fallback for unknown weapon")
+	}
+}
+
+func TestClassRepository_WeaponsByName(t *testing.T) {
+	all, simple, martial := fakeWeapons()
+	repo := NewClassRepository(all, simple, martial)
+
+	result := repo.WeaponsByName("dagger", "missing")
+
+	if result[0].Name != "dagger" {
+		t.Errorf("expected dagger")
+	}
+	if result[1].Name != "missing" {
+		t.Errorf("expected missing fallback")
+	}
+}
+
+func TestClassRepository_CombineWeaponSets(t *testing.T) {
+	all, simple, martial := fakeWeapons()
+	repo := NewClassRepository(all, simple, martial)
+
+	result := repo.CombineWeaponSets(simple, martial)
+	if len(result) != 2 {
+		t.Errorf("expected 2 weapons, got %d", len(result))
+	}
+}
diff --git a/domain/class_loadout.go b/domain/class_loadout.go
new file mode 100644
index 0000000..f51027e
--- /dev/null
+++ b/domain/class_loadout.go
@@ -0,0 +1,11 @@
+package domain
+
+type ClassLoadout struct {
+	MaxAllowed int
+	Skills     []string
+	Armor      []string
+	Shields    string
+	Weapons    []WeaponInfo
+	MainHand   string
+	OffHand    string
+}
diff --git a/service/combat_stats.go b/domain/equipment.go
similarity index 53%
rename from service/combat_stats.go
rename to domain/equipment.go
index 5ce01b8..dbb85e0 100644
--- a/service/combat_stats.go
+++ b/domain/equipment.go
@@ -1,11 +1,16 @@
-package service
+package domain
 
 import (
+	"errors"
 	"strings"
-
-	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
 )
 
+type Equipment struct {
+	Weapon map[string]string
+	Armor  string
+	Shield string
+}
+
 type ArmorInfo struct {
 	BaseAC   int
 	DexBonus string
@@ -29,11 +34,71 @@ var ArmorData = map[string]ArmorInfo{
 	"plate":      {BaseAC: 18, DexBonus: "none", Category: "heavy"},
 }
 
-func CalculateInitiative(s *domain.Stats) int {
-	return s.DexMod
+var (
+	ErrSlotOccupied = errors.New("slot already occupied")
+	ErrInvalidSlot  = errors.New("invalid slot")
+	ErrNoWeaponName = errors.New("weapon name cannot be empty")
+	ErrNoArmorName  = errors.New("armor name cannot be empty")
+	ErrNoShieldName = errors.New("shield name cannot be empty")
+)
+
+func (c *Character) EquipWeapon(slot, weapon string) error {
+	slot = strings.ToLower(strings.TrimSpace(slot))
+	if weapon == "" {
+		return ErrNoWeaponName
+	}
+
+	if slot != "main hand" && slot != "off hand" {
+		return ErrInvalidSlot
+	}
+
+	if c.Equipment.Weapon == nil {
+		c.Equipment.Weapon = make(map[string]string)
+	}
+
+	if existing, ok := c.Equipment.Weapon[slot]; ok && existing != "" {
+		return ErrSlotOccupied
+	}
+
+	c.Equipment.Weapon[slot] = weapon
+	return nil
+}
+
+func (c *Character) EquipArmor(armor string) error {
+	if armor == "" {
+		return ErrNoArmorName
+	}
+
+	c.Equipment.Armor = armor
+	return nil
+}
+
+func (c *Character) EquipShield(shield string) error {
+	if shield == "" {
+		return ErrNoShieldName
+	}
+
+	c.Equipment.Shield = shield
+	return nil
+}
+
+func (c *Character) CalculateInitiative() int {
+	return c.Stats.DexMod
+}
+
+func (c *Character) CalculatePassivePerception() int {
+	base := 10 + c.Stats.WisMod
+
+	for _, skill := range c.Skills.Skills {
+		if skill == "perception" {
+			base += c.Proficiency
+			break
+		}
+	}
+	return base
 }
 
-func CalculateArmorClass(c *domain.Character) int {
+func (c *Character) CalculateArmorClass() int {
 	s := &c.Stats
 	e := &c.Equipment
 	class := strings.ToLower(c.Class)
@@ -55,7 +120,7 @@ func CalculateArmorClass(c *domain.Character) int {
 				}
 				ac += dex
 			case "none":
-				// no bolus
+				// no bonus
 			}
 		}
 
diff --git a/domain/equipment_test.go b/domain/equipment_test.go
new file mode 100644
index 0000000..6dca97c
--- /dev/null
+++ b/domain/equipment_test.go
@@ -0,0 +1,114 @@
+package domain
+
+import "testing"
+
+func newChar() *Character {
+	return &Character{
+		Equipment: Equipment{Weapon: map[string]string{}},
+		Stats:     Stats{DexMod: 2, WisMod: 1, ConMod: 3},
+		Skills:    ClassLoadout{Skills: []string{}},
+	}
+}
+
+func TestEquipWeapon(t *testing.T) {
+	c := newChar()
+
+	if err := c.EquipWeapon("main hand", "sword"); err != nil {
+		t.Errorf("unexpected error: %v", err)
+	}
+
+	if err := c.EquipWeapon("main hand", "axe"); err != ErrSlotOccupied {
+		t.Errorf("expected ErrSlotOccupied, got %v", err)
+	}
+
+	if err := c.EquipWeapon("foot", "dagger"); err != ErrInvalidSlot {
+		t.Errorf("expected ErrInvalidSlot, got %v", err)
+	}
+
+	if err := c.EquipWeapon("off hand", ""); err != ErrNoWeaponName {
+		t.Errorf("expected ErrNoWeaponName, got %v", err)
+	}
+}
+
+func TestEquipArmorAndShield(t *testing.T) {
+	c := newChar()
+
+	if err := c.EquipArmor(""); err != ErrNoArmorName {
+		t.Errorf("expected ErrNoArmorName, got %v", err)
+	}
+	if err := c.EquipArmor("chain mail"); err != nil {
+		t.Errorf("unexpected error: %v", err)
+	}
+	if c.Equipment.Armor != "chain mail" {
+		t.Errorf("armor not set correctly")
+	}
+
+	if err := c.EquipShield(""); err != ErrNoShieldName {
+		t.Errorf("expected ErrNoShieldName, got %v", err)
+	}
+	if err := c.EquipShield("shield"); err != nil {
+		t.Errorf("unexpected error: %v", err)
+	}
+	if c.Equipment.Shield != "shield" {
+		t.Errorf("shield not set correctly")
+	}
+}
+
+func TestCalculateInitiative(t *testing.T) {
+	c := newChar()
+	if got := c.CalculateInitiative(); got != 2 {
+		t.Errorf("expected 2, got %d", got)
+	}
+}
+
+func TestCalculatePassivePerception(t *testing.T) {
+	// without perception proficiency
+	c := newChar()
+	if got := c.CalculatePassivePerception(); got != 11 {
+		t.Errorf("expected 11, got %d", got)
+	}
+
+	// with perception proficiency
+	c.Skills.Skills = []string{"perception"}
+	c.Proficiency = 2
+	if got := c.CalculatePassivePerception(); got != 13 {
+		t.Errorf("expected 13, got %d", got)
+	}
+}
+
+func TestCalculateArmorClass(t *testing.T) {
+	// No armor, no shield
+	c := newChar()
+	c.Class = "fighter"                          // normal class
+	if ac := c.CalculateArmorClass(); ac != 12 { // 10 + DexMod 2
+		t.Errorf("expected 12, got %d", ac)
+	}
+
+	// Armor + full Dex bonus
+	c.EquipArmor("leather") // base 11 + dexMod 2
+	if ac := c.CalculateArmorClass(); ac != 13 {
+		t.Errorf("expected 13, got %d", ac)
+	}
+
+	// Shield adds +2
+	c.EquipShield("shield")
+	if ac := c.CalculateArmorClass(); ac != 15 {
+		t.Errorf("expected 15, got %d", ac)
+	}
+
+	// Barbarian unarmored defense = 10 + Dex + Con
+	b := newChar()
+	b.Class = "barbarian"
+	b.Stats.ConMod = 3
+	if ac := b.CalculateArmorClass(); ac != 15 { // 10 + 2 + 3
+		t.Errorf("barbarian expected 15, got %d", ac)
+	}
+
+	// Monk unarmored defense = 10 + Dex + Wis
+	m := newChar()
+	m.Class = "monk"
+	m.Stats.WisMod = 2
+	if ac := m.CalculateArmorClass(); ac != 14 { // 10 + 2 + 2
+		t.Errorf("monk expected 14, got %d", ac)
+	}
+}
diff --git a/domain/race_skills.go b/domain/race_skills.go
new file mode 100644
index 0000000..3119932
--- /dev/null
+++ b/domain/race_skills.go
@@ -0,0 +1,29 @@
+package domain
+
+import "strings"
+
+var racialSkillProficiencies = map[string][]string{
+	"dwarf":              {"history"},
+	"hill-dwarf":         {"history"},
+	"elf":                {"perception"},
+	"halfling":           {},
+	"lightfoot-halfling": {},
+	"half-elf":           {"insight", "perception"},
+	"half-orc":           {"intimidation"},
+	"gnome":              {},
+	"rock gnome":         {"history"},
+	"human":              {},
+	"dragonborn":         {},
+	"tiefling":           {},
+}
+
+func (c *Character) ApplyRacialSkillProficiencies() {
+	race := strings.ToLower(strings.ReplaceAll(c.Race, " ", "-"))
+
+	skills, ok := racialSkillProficiencies[race]
+	if !ok {
+		return
+	}
+
+	c.Skills.Skills = append(c.Skills.Skills, skills...)
+}
diff --git a/domain/race_skills_test.go b/domain/race_skills_test.go
new file mode 100644
index 0000000..c9a82f9
--- /dev/null
+++ b/domain/race_skills_test.go
@@ -0,0 +1,63 @@
+package domain_test
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestApplyRacialSkillProficiencies(t *testing.T) {
+	tests := []struct {
+		name     string
+		race     string
+		initial  []string
+		expected []string
+	}{
+		{name: "Dwarf adds history",
+			race:     "Dwarf",
+			initial:  []string{"acrobatics", "athletics", "deception", "insight"},
+			expected: []string{"acrobatics", "athletics", "deception", "insight", "history"},
+		},
+		{
+			name:     "Half-orc add intimidation",
+			race:     "Half-orc",
+			initial:  []string{"animal handling", "athletics", "insight", "religion"},
+			expected: []string{"animal handling", "athletics", "insight", "religion", "intimidation"},
+		},
+		{
+			name:     "Unknown race does nothing",
+			race:     "Unknown",
+			initial:  []string{""},
+			expected: []string{""},
+		},
+		{
+			name:     "Duplicate skills allowed",
+			race:     "Dwarf",
+			initial:  []string{"history"},
+			expected: []string{"history", "history"},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			char := &domain.Character{
+				Race: tt.race,
+				Skills: domain.ClassLoadout{
+					Skills: append([]string{}, tt.initial...),
+				},
+			}
+
+			char.ApplyRacialSkillProficiencies()
+
+			if len(char.Skills.Skills) != len(tt.expected) {
+				t.Fatalf("expected %v skills, got %v", tt.expected, char.Skills.Skills)
+			}
+
+			for i, exp := range tt.expected {
+				if char.Skills.Skills[i] != exp {
+					t.Errorf("expected %v at %d, got %v", exp, i, char.Skills.Skills[i])
+				}
+			}
+		})
+	}
+}
diff --git a/domain/repository.go b/domain/repository.go
new file mode 100644
index 0000000..578039e
--- /dev/null
+++ b/domain/repository.go
@@ -0,0 +1,8 @@
+package domain
+
+type Repository interface {
+	Save(character *Character) error
+	Load(name string) (*Character, error)
+	List() ([]*Character, error)
+	Delete(name string) error
+}
diff --git a/domain/sanitize_key_test.go b/domain/sanitize_key_test.go
new file mode 100644
index 0000000..0803653
--- /dev/null
+++ b/domain/sanitize_key_test.go
@@ -0,0 +1,28 @@
+package domain
+
+import "testing"
+
+func TestSanitizeLocalKey(t *testing.T) {
+	cases := map[string]string{
+		"Leather Armor":   "leather",
+		"Chain Shirt":     "chain-shirt",
+		"Scale Mail":      "scale-mail",
+		"Padded Armor":    "padded",
+		"Half Plate":      "half-plate",
+		"Studded Leather": "studded-leather",
+		"Ring Mail":       "ring-mail",
+		"chain-mail":      "chain-mail",
+		"Plate Armor":     "plate",
+		"Hide":            "hide",
+		"Shield":          "shield",
+		"Mace (Silvered)": "mace-silvered",
+		"breast plate":    "breast-plate",
+	}
+
+	for input, want := range cases {
+		got := SanitizeLocalKey(input)
+		if got != want {
+			t.Errorf("SanitizeLocalKey(%q) = %q, want %q", input, got, want)
+		}
+	}
+}
diff --git a/domain/spellcast.go b/domain/spellcast.go
new file mode 100644
index 0000000..3628ca1
--- /dev/null
+++ b/domain/spellcast.go
@@ -0,0 +1,39 @@
+package domain
+
+import "strings"
+
+type Spellcasting struct {
+	CantripsKnown    int
+	SpellsKnown      int
+	CanCast          bool
+	CasterType       string
+	LearnedSpells    []string    `json:"learned_spells"`
+	PreparedSpells   []string    `json:"prepared_spells"`
+	Slots            map[int]int `json:"slots"`
+	MaxSlots         map[int]int `json:"maxslots"`
+	PreparedMode     bool
+	LearnedMode      bool
+	Ability          string
+	SpellSaveDC      int
+	SpellAttackBonus int
+}
+
+type SpellInfo struct {
+	Name   string `json:"name"`
+	Level  int    `json:"level"`
+	School string `json:"school"`
+	Range  string `json:"range"`
+}
+
+func GetSpellcastingType(class string) string {
+	switch strings.ToLower(class) {
+	case "bard", "cleric", "druid", "sorcerer", "wizard":
+		return "full"
+	case "paladin", "ranger":
+		return "half"
+	case "warlock":
+		return "pact"
+	default:
+		return ""
+	}
+}
diff --git a/domain/spellcast_test.go b/domain/spellcast_test.go
new file mode 100644
index 0000000..12b7c97
--- /dev/null
+++ b/domain/spellcast_test.go
@@ -0,0 +1,38 @@
+package domain_test
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestGetSpellcastingType(t *testing.T) {
+	tests := []struct {
+		class string
+		want  string
+	}{
+		{"Bard", "full"},
+		{"cleric", "full"},
+		{"Druid", "full"},
+		{"sorcerer", "full"},
+		{"wizard", "full"},
+
+		{"paladin", "half"},
+		{"Ranger", "half"},
+
+		{"Warlock", "pact"},
+
+		{"fighter", ""},
+		{"barbarian", ""},
+		{"rogue", ""},
+		{"", ""},
+	}
+
+	for _, tt := range tests {
+		got := domain.GetSpellcastingType(tt.class)
+		if got != tt.want {
+			t.Errorf("GetSpellcastingType(%q) = %q, want %q",
+				tt.class, got, tt.want)
+		}
+	}
+}
diff --git a/domain/stats.go b/domain/stats.go
new file mode 100644
index 0000000..76f2ce7
--- /dev/null
+++ b/domain/stats.go
@@ -0,0 +1,29 @@
+package domain
+
+type Stats struct {
+	Str    int
+	StrMod int
+
+	Dex    int
+	DexMod int
+
+	Con    int
+	ConMod int
+
+	Intel    int
+	IntelMod int
+
+	Wis    int
+	WisMod int
+
+	Cha    int
+	ChaMod int
+}
+
+func abilityModifier(score int) int {
+	result := (score - 10) / 2
+	if (score-10)%2 < 0 {
+		result--
+	}
+	return result
+}
diff --git a/domain/stats_test.go b/domain/stats_test.go
new file mode 100644
index 0000000..bf5ff7a
--- /dev/null
+++ b/domain/stats_test.go
@@ -0,0 +1,31 @@
+package domain_test
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestAbilityModifier(t *testing.T) {
+	tests := []struct {
+		score int
+		want  int
+	}{
+		{10, 0},
+		{8, -1},
+		{14, 2},
+		{17, 3},
+	}
+
+	for _, tt := range tests {
+		stats := domain.Stats{
+			Str: tt.score,
+		}
+		c := &domain.Character{Stats: stats}
+		c.UpdateProficiency()
+
+		if c.Stats.StrMod != tt.want {
+			t.Errorf("Str=%d â†’ want mod %d, got %d", tt.score, tt.want, c.Stats.StrMod)
+		}
+	}
+}
diff --git a/domain/weapon_info.go b/domain/weapon_info.go
new file mode 100644
index 0000000..30d555b
--- /dev/null
+++ b/domain/weapon_info.go
@@ -0,0 +1,8 @@
+package domain
+
+type WeaponInfo struct {
+	Name      string
+	Category  string
+	Range     int
+	TwoHanded bool
+}
diff --git a/main.go b/main.go
index 0b986b0..cf52e1a 100755
--- a/main.go
+++ b/main.go
@@ -6,12 +6,11 @@ import (
 	"log"
 	"net/http"
 	"os"
-	"strings"
 
 	"path/filepath"
 
-	"github.com/DanielBartha/MPP-DnD-Character-Gen/characterClasses"
 	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain/class"
 	"github.com/DanielBartha/MPP-DnD-Character-Gen/repository"
 	"github.com/DanielBartha/MPP-DnD-Character-Gen/service"
 )
@@ -51,8 +50,6 @@ func main() {
 	simple := service.SimpleWeapons(allWeps)
 	martial := service.MartialWeapons(allWeps)
 
-	characterClasses.InitWeapons(allWeps, simple, martial)
-
 	switch cmd {
 	case "create":
 		createCmd := flag.NewFlagSet("create", flag.ExitOnError)
@@ -61,7 +58,7 @@ func main() {
 		race := createCmd.String("race", "", "character race (required)")
 		// "acolyte" default
 		background := createCmd.String("background", "acolyte", "character background (required)")
-		class := createCmd.String("class", "", "character class (required)")
+		className := createCmd.String("class", "", "character class (required)")
 		level := createCmd.Int("level", 1, "character level (required)")
 
 		str := createCmd.Int("str", 10, "strength is required")
@@ -71,69 +68,31 @@ func main() {
 		wis := createCmd.Int("wis", 10, "wisdom is required")
 		cha := createCmd.Int("cha", 10, "charisma is required")
 
-		err := createCmd.Parse(os.Args[2:])
-		if err != nil {
-			fmt.Println("error parsing flags")
-			createCmd.Usage()
-			os.Exit(2)
-		}
-
-		if *name == "" {
-			fmt.Println("name is required")
-			os.Exit(2)
-		}
-		if *race == "" {
-			fmt.Println("race is required")
-			os.Exit(2)
-		}
-		if *class == "" {
-			fmt.Println("class is required")
-			os.Exit(2)
-		}
-		if *level <= 0 {
-			fmt.Println("level is required")
+		if err := createCmd.Parse(os.Args[2:]); err != nil {
+			fmt.Println("error parsing flags:", err)
 			os.Exit(2)
 		}
 
-		characterCreate := domain.Character{
-			Name:       *name,
-			Race:       *race,
-			Background: *background,
-			Class:      *class,
-			Level:      *level,
-			Stats: domain.Stats{
-				Str:   *str,
-				Dex:   *dex,
-				Con:   *con,
-				Intel: *intel,
-				Wis:   *wis,
-				Cha:   *cha,
-			},
+		stats := domain.Stats{
+			Str: *str, Dex: *dex, Con: *con, Intel: *intel, Wis: *wis, Cha: *cha,
 		}
 
-		svc := service.NewCharacterService()
-
-		characterCreate.Skills = svc.GetClassSkills(&characterCreate)
-		svc.ApplyRacialBonuses(&characterCreate)
-		svc.UpdateProficiency(&characterCreate)
-		svc.InitSpellcasting(&characterCreate)
-
-		characterCreate.Equipment = domain.Equipment{
-			Weapon: map[string]string{
-				"main hand": "",
-				"off hand":  "",
-			},
-			Armor:  "",
-			Shield: "",
+		char, err := domain.NewCharacter(*name, *race, *background, *className, *level, stats)
+		if err != nil {
+			fmt.Println("Error creating character:", err)
+			os.Exit(2)
 		}
 
 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
-		if err := repo.Save(&characterCreate); err != nil {
-			fmt.Println("error saving character:", err)
+		classRepo := class.NewClassRepository(allWeps, simple, martial)
+		facade := service.NewCharacterFacade(repo, classRepo)
+
+		if err := facade.CreateCharacter(char); err != nil {
+			fmt.Println("Error creating character: ", err)
 			os.Exit(2)
 		}
 
-		fmt.Printf("saved character %+v\n", characterCreate.Name)
+		fmt.Printf("saved character %s\n", char.Name)
 
 	case "view":
 		viewCmd := flag.NewFlagSet("view", flag.ExitOnError)
@@ -146,93 +105,32 @@ func main() {
 		}
 
 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
-		character, err := repo.Load(*name)
+		facade := service.NewCharacterFacade(repo, nil)
+
+		char, err := facade.ViewCharacter(*name)
 		if err != nil {
 			fmt.Printf("character %q not found\n", *name)
 			return
 		}
 
-		fmt.Printf(
-			"Name: %s\n"+
-				"Class: %s\n"+
-				"Race: %s\n"+
-				"Background: %s\n"+
-				"Level: %d\n"+
-				"Ability scores:\n"+
-				"  STR: %d (%+d)\n"+
-				"  DEX: %d (%+d)\n"+
-				"  CON: %d (%+d)\n"+
-				"  INT: %d (%+d)\n"+
-				"  WIS: %d (%+d)\n"+
-				"  CHA: %d (%+d)\n"+
-				"Proficiency bonus: +%d\n"+
-				"Skill proficiencies: %s\n",
-			character.Name,
-			strings.ToLower(character.Class),
-			strings.ToLower(character.Race),
-			character.Background,
-			character.Level,
-			character.Stats.Str, character.Stats.StrMod,
-			character.Stats.Dex, character.Stats.DexMod,
-			character.Stats.Con, character.Stats.ConMod,
-			character.Stats.Intel, character.Stats.IntelMod,
-			character.Stats.Wis, character.Stats.WisMod,
-			character.Stats.Cha, character.Stats.ChaMod,
-			character.Proficiency,
-			strings.Join(character.Skills.Skills, ", "),
-		)
-
-		if character.Spellcasting != nil && character.Spellcasting.CanCast {
-			fmt.Println("Spell slots:")
-
-			if character.Spellcasting.CantripsKnown > 0 {
-				fmt.Printf("  Level 0: %d\n", character.Spellcasting.CantripsKnown)
-			}
-
-			for lvl := 1; lvl <= 9; lvl++ {
-				if count, ok := character.Spellcasting.MaxSlots[lvl]; ok && count > 0 {
-					fmt.Printf("  Level %d: %d\n", lvl, count)
-				}
-			}
-
-			if character.Spellcasting.Ability != "" {
-				fmt.Printf("Spellcasting ability: %s\n", strings.ToLower(character.Spellcasting.Ability))
-				fmt.Printf("Spell save DC: %d\n", character.Spellcasting.SpellSaveDC)
-				fmt.Printf("Spell attack bonus: +%d\n", character.Spellcasting.SpellAttackBonus)
-			}
-		}
-
-		if weapon, ok := character.Equipment.Weapon["main hand"]; ok && weapon != "" {
-			fmt.Printf("Main hand: %s\n", weapon)
-		}
-
-		if weapon, ok := character.Equipment.Weapon["off hand"]; ok && weapon != "" {
-			fmt.Printf("Off hand: %s\n", weapon)
-		}
-		if character.Equipment.Armor != "" {
-			fmt.Printf("Armor: %s\n", character.Equipment.Armor)
-		}
-
-		if character.Equipment.Shield != "" {
-			fmt.Printf("Shield: %s\n", character.Equipment.Shield)
-		}
-
-		fmt.Printf("Armor class: %d\n", service.CalculateArmorClass(character))
-		fmt.Printf("Initiative bonus: %d\n", service.CalculateInitiative(&character.Stats))
-		fmt.Printf("Passive perception: %d\n", service.CalculatePassivePerception(character))
+		fmt.Print(service.FormatCharacterView(char))
 
 	case "list":
 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
-		characters, err := repo.List()
+		facade := service.NewCharacterFacade(repo, nil)
+
+		chars, err := facade.ListCharacters()
 		if err != nil {
-			fmt.Println("error listing characters:", err)
+			fmt.Println("error listing characters: ", err)
 			os.Exit(2)
 		}
-		if len(characters) == 0 {
+
+		if len(chars) == 0 {
 			fmt.Println("no characters found")
 			return
 		}
-		for _, c := range characters {
+
+		for _, c := range chars {
 			fmt.Printf("- %s (%s %s)\n", c.Name, c.Race, c.Class)
 		}
 
@@ -247,10 +145,13 @@ func main() {
 		}
 
 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
-		if err := repo.Delete(*name); err != nil {
-			fmt.Println("error deleting character:", err)
+		facade := service.NewCharacterFacade(repo, nil)
+
+		if err := facade.DeleteCharacter(*name); err != nil {
+			fmt.Println("error deleting character: ", err)
 			os.Exit(2)
 		}
+
 		fmt.Printf("deleted %s\n", *name)
 
 	case "equip":
@@ -268,47 +169,31 @@ func main() {
 		}
 
 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
-		character, err := repo.Load(*name)
-		if err != nil {
-			fmt.Printf("character %q not found\n", *name)
-			return
-		}
+		classRepo := class.NewClassRepository(allWeps, simple, martial)
+		facade := service.NewCharacterFacade(repo, classRepo)
 
-		if *weapon != "" && *slot != "" {
-			if character.Equipment.Weapon == nil {
-				character.Equipment.Weapon = make(map[string]string)
-			}
-
-			if existing, ok := character.Equipment.Weapon[*slot]; ok && existing != "" {
+		err := facade.EquipItem(*name, *weapon, *slot, *armor, *shield)
+		if err != nil {
+			switch err {
+			case domain.ErrSlotOccupied:
 				fmt.Printf("%s already occupied\n", *slot)
 				return
-			}
 
-			character.Equipment.Weapon[*slot] = *weapon
-			if err := repo.Save(character); err != nil {
-				fmt.Printf("error saving character: %v\n", err)
+			default:
+				fmt.Println("error equipping:", err)
 				os.Exit(2)
 			}
+		}
+
+		if *weapon != "" && *slot != "" {
 			fmt.Printf("Equipped weapon %s to %s\n", *weapon, *slot)
 			return
 		}
-
 		if *armor != "" {
-			character.Equipment.Armor = *armor
-			if err := repo.Save(character); err != nil {
-				fmt.Println("error saving character:", *armor)
-				os.Exit(2)
-			}
 			fmt.Printf("Equipped armor %s\n", *armor)
 			return
 		}
-
 		if *shield != "" {
-			character.Equipment.Shield = *shield
-			if err := repo.Save(character); err != nil {
-				fmt.Println("error saving character:", err)
-				os.Exit(2)
-			}
 			fmt.Printf("Equipped shield %s\n", *shield)
 			return
 		}
@@ -327,57 +212,15 @@ func main() {
 		}
 
 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
-		character, err := repo.Load(*name)
-		if err != nil {
-			fmt.Printf("character %q not found\n", *name)
-			return
-		}
-
-		if character.Spellcasting == nil || !character.Spellcasting.CanCast {
-			fmt.Printf("this class can't cast spells\n")
-			return
-		}
-
-		for _, s := range character.Spellcasting.LearnedSpells {
-			if strings.EqualFold(s, *spell) {
-				fmt.Printf("%s already learned\n", *spell)
-				return
-			}
-		}
+		facade := service.NewCharacterFacade(repo, nil)
 
-		if character.Spellcasting.PreparedMode {
-			fmt.Printf("this class prepares spells and can't learn them\n")
-			return
-		}
-
-		// checks for non-existing spells (csv)
-		level, err := service.GetSpellLevel(*spell)
+		message, err := facade.LearnSpell(*name, *spell)
 		if err != nil {
 			fmt.Println(err)
 			return
 		}
 
-		if !service.IsSpellForClass(*spell, character.Class) {
-			fmt.Printf("%s cannot learn %s\n", character.Class, *spell)
-			return
-		}
-
-		if level > 0 {
-			if slots, ok := character.Spellcasting.Slots[level]; !ok || slots == 0 {
-				fmt.Printf("the spell has higher level than the available spell slots\n")
-				return
-			}
-		}
-
-		character.Spellcasting.LearnedMode = true
-		character.Spellcasting.LearnedSpells = append(character.Spellcasting.LearnedSpells, *spell)
-
-		if err := repo.Save(character); err != nil {
-			fmt.Println("error saving character:", err)
-			os.Exit(2)
-		}
-
-		fmt.Printf("Learned spell %s\n", *spell)
+		fmt.Println(message)
 
 	case "prepare-spell":
 		prepareCmd := flag.NewFlagSet("prepare-spell", flag.ExitOnError)
@@ -391,57 +234,15 @@ func main() {
 		}
 
 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
-		character, err := repo.Load(*name)
-		if err != nil {
-			fmt.Printf("character %q not found\n", *name)
-			return
-		}
-
-		if character.Spellcasting == nil || !character.Spellcasting.CanCast {
-			fmt.Printf("this class can't cast spells\n")
-			return
-		}
-
-		for _, s := range character.Spellcasting.PreparedSpells {
-			if strings.EqualFold(s, *spell) {
-				fmt.Printf("%s already prepared\n", *spell)
-				return
-			}
-		}
-
-		if character.Spellcasting.LearnedMode {
-			fmt.Printf("this class learns spells and can't prepare them\n")
-			return
-		}
+		facade := service.NewCharacterFacade(repo, nil)
 
-		// checks for non-existing spells (csv)
-		level, err := service.GetSpellLevel(*spell)
+		message, err := facade.PrepareSpell(*name, *spell)
 		if err != nil {
 			fmt.Println(err)
 			return
 		}
 
-		if !service.IsSpellForClass(*spell, character.Class) {
-			fmt.Printf("%s cannot prepare %s\n", character.Class, *spell)
-			return
-		}
-
-		if level > 0 {
-			if slots, ok := character.Spellcasting.Slots[level]; !ok || slots == 0 {
-				fmt.Printf("the spell has higher level than the available spell slots\n")
-				return
-			}
-		}
-
-		character.Spellcasting.PreparedMode = true
-		character.Spellcasting.PreparedSpells = append(character.Spellcasting.PreparedSpells, *spell)
-
-		if err := repo.Save(character); err != nil {
-			fmt.Println("error saving character:", err)
-			os.Exit(2)
-		}
-
-		fmt.Printf("Prepared spell %s\n", *spell)
+		fmt.Println(message)
 
 	case "enrich-spells":
 		input := "5e-SRD-Spells.csv"
diff --git a/refactor.diff b/refactor.diff
new file mode 100644
index 0000000..adb0283
--- /dev/null
+++ b/refactor.diff
@@ -0,0 +1,2935 @@
+diff --git a/characterClasses/classes.go b/characterClasses/classes.go
+deleted file mode 100644
+index 06f65cf..0000000
+--- a/characterClasses/classes.go
++++ /dev/null
+@@ -1,236 +0,0 @@
+-package characterClasses
+-
+-import (
+-	"strings"
+-
+-	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+-)
+-
+-var (
+-	AllWeapons     []domain.WeaponInfo
+-	SimpleWeapons  []domain.WeaponInfo
+-	MartialWeapons []domain.WeaponInfo
+-)
+-
+-type ClassSkills struct {
+-	MaxAllowed int
+-	Skills     []string
+-	Armor      []string
+-	Shields    string
+-	Weapons    []domain.WeaponInfo
+-	MainHand   string
+-	OffHand    string
+-}
+-
+-func InitWeapons(all, simple, martial []domain.WeaponInfo) {
+-	AllWeapons = append([]domain.WeaponInfo{}, all...)
+-	SimpleWeapons = append([]domain.WeaponInfo{}, simple...)
+-	MartialWeapons = append([]domain.WeaponInfo{}, martial...)
+-}
+-
+-func findWeaponByName(name string) domain.WeaponInfo {
+-	for _, w := range AllWeapons {
+-		if strings.EqualFold(w.Name, name) {
+-			return w
+-		}
+-	}
+-	return domain.WeaponInfo{Name: name}
+-}
+-
+-func CombineWeaponSets(sets ...[]domain.WeaponInfo) []domain.WeaponInfo {
+-	out := make([]domain.WeaponInfo, 0)
+-	for _, s := range sets {
+-		out = append(out, s...)
+-	}
+-	return out
+-}
+-
+-func WithExtraWeapons(base []domain.WeaponInfo, names ...string) []domain.WeaponInfo {
+-	out := append([]domain.WeaponInfo{}, base...)
+-	for _, n := range names {
+-		out = append(out, findWeaponByName(n))
+-	}
+-	return out
+-}
+-
+-func WeaponsByName(names ...string) []domain.WeaponInfo {
+-	out := make([]domain.WeaponInfo, 0, len(names))
+-	for _, n := range names {
+-		out = append(out, findWeaponByName(n))
+-	}
+-	return out
+-}
+-
+-var Classes = map[string]ClassSkills{
+-	"barbarian": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"animal handling", "athletics", "intimidation", "nature", "perception", "survival",
+-		},
+-		Armor: []string{
+-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
+-		},
+-		Shields:  "shield",
+-		Weapons:  AllWeapons,
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"bard": {
+-		MaxAllowed: 3,
+-		Skills: []string{
+-			"acrobatics", "animal handling", "arcana", "athletics", "deception",
+-			"history", "insight", "intimidation", "investigation", "medicine", "nature",
+-			"perception", "performance", "persuasion", "religion", "sleight of hand", "stealth", "survival",
+-		},
+-		Armor: []string{
+-			"padded", "leather", "studded leather",
+-		},
+-		Weapons: WithExtraWeapons(
+-			SimpleWeapons,
+-			"hand crossbow", "longsword", "rapier", "shortsword",
+-		),
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"cleric": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"history", "insight", "medicine", "persuasion", "religion",
+-		},
+-		Armor: []string{
+-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
+-		},
+-		Shields:  "shield",
+-		Weapons:  SimpleWeapons,
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"druid": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"arcana", "animal handling", "insight", "medicine", "nature", "perception", "religion", "survival",
+-		},
+-		// druids don't wear armor or shields made of metal, fucking animals
+-		Armor: []string{
+-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
+-		},
+-		Shields: "shield",
+-		Weapons: append(SimpleWeapons,
+-			findWeaponByName("club"),
+-			findWeaponByName("greatclub"),
+-			findWeaponByName("dagger"),
+-			findWeaponByName("dart"),
+-			findWeaponByName("javelins"),
+-			findWeaponByName("maces"),
+-			findWeaponByName("quarterstaff"),
+-			findWeaponByName("scimitar"),
+-			findWeaponByName("sickle"),
+-			findWeaponByName("sling"),
+-			findWeaponByName("spear"),
+-		),
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"fighter": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"acrobatics", "animal handling", "athletics", "history", "insight", "intimidation", "perception", "survival",
+-		},
+-		Armor: []string{
+-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate", "ring mail", "chain mail", "splint", "plate",
+-		},
+-		Shields:  "shield",
+-		Weapons:  AllWeapons,
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"monk": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"acrobatics", "athletics", "history", "insight", "religion", "stealth",
+-		},
+-		// NO ARMOR
+-		Weapons: append(SimpleWeapons,
+-			findWeaponByName("shortsword"),
+-		),
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"paladin": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"athletics", "insight", "intimidation", "medicine", "persuasion", "religion",
+-		},
+-		Armor: []string{
+-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate", "ring mail", "chain mail", "splint", "plate",
+-		},
+-		Shields:  "shield",
+-		Weapons:  AllWeapons,
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"ranger": {
+-		MaxAllowed: 3,
+-		Skills: []string{
+-			"animal handling", "athletics", "insight", "investigation", "nature", "perception", "stealth", "survival",
+-		},
+-		Armor: []string{
+-			"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
+-		},
+-		Shields:  "shield",
+-		Weapons:  AllWeapons,
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"rogue": {
+-		MaxAllowed: 4,
+-		Skills: []string{
+-			"acrobatics", "athletics", "deception", "insight", "intimidation", "investigation", "perception", "performance", "persuasion", "sleight of hand", "stealth",
+-		},
+-		Armor: []string{
+-			"padded", "leather", "studded leather",
+-		},
+-		Weapons: WithExtraWeapons(
+-			SimpleWeapons,
+-			"hand crossbow", "longsword", "rapier", "shortsword",
+-		),
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"sorcerer": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"arcana", "deception", "insight", "intimidation", "persuasion", "religion",
+-		},
+-		// NO ARMOR
+-		Weapons: WeaponsByName(
+-			"dagger", "dart", "sling", "quarterstaff", "light crossbow",
+-		),
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"warlock": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"arcana", "deception", "history", "intimidation", "investigation", "nature", "religion",
+-		},
+-		Armor: []string{
+-			"padded", "leather", "studded leather",
+-		},
+-		Weapons:  SimpleWeapons,
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-	"wizard": {
+-		MaxAllowed: 2,
+-		Skills: []string{
+-			"arcana", "history", "insight", "investigation", "medicine", "religion",
+-		},
+-		// NO ARMOR
+-		Weapons: WeaponsByName(
+-			"dagger", "dart", "sling", "quarterstaff", "light crossbow",
+-		),
+-		MainHand: "main hand",
+-		OffHand:  "off hand",
+-	},
+-}
+diff --git a/data/characters.json b/data/characters.json
+deleted file mode 100644
+index a801f76..0000000
+--- a/data/characters.json
++++ /dev/null
+@@ -1,841 +0,0 @@
+-[
+-  {
+-    "Name": "Gandalf",
+-    "Race": "human",
+-    "Background": "acolyte",
+-    "Class": "wizard",
+-    "Level": 20,
+-    "Proficiency": 6,
+-    "Stats": {
+-      "Str": 9,
+-      "StrMod": -1,
+-      "Dex": 11,
+-      "DexMod": 0,
+-      "Con": 13,
+-      "ConMod": 1,
+-      "Intel": 15,
+-      "IntelMod": 2,
+-      "Wis": 16,
+-      "WisMod": 3,
+-      "Cha": 14,
+-      "ChaMod": 2
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "arcana",
+-        "history",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": null,
+-      "Shields": "",
+-      "Weapons": [
+-        {
+-          "Name": "dagger",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "dart",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "sling",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "quarterstaff",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "light crossbow",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        }
+-      ],
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "",
+-      "Shield": ""
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 5,
+-      "SpellsKnown": 0,
+-      "CanCast": true,
+-      "CasterType": "full",
+-      "learned_spells": [],
+-      "prepared_spells": [
+-        "burning hands"
+-      ],
+-      "slots": {
+-        "1": 4,
+-        "2": 3,
+-        "3": 3,
+-        "4": 3,
+-        "5": 3,
+-        "6": 2,
+-        "7": 2,
+-        "8": 1,
+-        "9": 1
+-      },
+-      "maxslots": {
+-        "1": 4,
+-        "2": 3,
+-        "3": 3,
+-        "4": 3,
+-        "5": 3,
+-        "6": 2,
+-        "7": 2,
+-        "8": 1,
+-        "9": 1
+-      },
+-      "PreparedMode": true,
+-      "LearnedMode": false,
+-      "Ability": "intelligence",
+-      "SpellSaveDC": 16,
+-      "SpellAttackBonus": 8
+-    },
+-    "ArmorClass": 10,
+-    "InitiativeBonus": 0,
+-    "PassivePerception": 13
+-  },
+-  {
+-    "Name": "Galadriel",
+-    "Race": "high elf",
+-    "Background": "acolyte",
+-    "Class": "sorcerer",
+-    "Level": 20,
+-    "Proficiency": 6,
+-    "Stats": {
+-      "Str": 8,
+-      "StrMod": -1,
+-      "Dex": 10,
+-      "DexMod": 0,
+-      "Con": 12,
+-      "ConMod": 1,
+-      "Intel": 15,
+-      "IntelMod": 2,
+-      "Wis": 14,
+-      "WisMod": 2,
+-      "Cha": 13,
+-      "ChaMod": 1
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "arcana",
+-        "deception",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": null,
+-      "Shields": "",
+-      "Weapons": [
+-        {
+-          "Name": "dagger",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "dart",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "sling",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "quarterstaff",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "light crossbow",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        }
+-      ],
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "",
+-      "Shield": ""
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 5,
+-      "SpellsKnown": 0,
+-      "CanCast": true,
+-      "CasterType": "full",
+-      "learned_spells": [
+-        "false life"
+-      ],
+-      "prepared_spells": [],
+-      "slots": {
+-        "1": 4,
+-        "2": 3,
+-        "3": 3,
+-        "4": 3,
+-        "5": 3,
+-        "6": 2,
+-        "7": 2,
+-        "8": 1,
+-        "9": 1
+-      },
+-      "maxslots": {
+-        "1": 4,
+-        "2": 3,
+-        "3": 3,
+-        "4": 3,
+-        "5": 3,
+-        "6": 2,
+-        "7": 2,
+-        "8": 1,
+-        "9": 1
+-      },
+-      "PreparedMode": false,
+-      "LearnedMode": true,
+-      "Ability": "charisma",
+-      "SpellSaveDC": 15,
+-      "SpellAttackBonus": 7
+-    },
+-    "ArmorClass": 10,
+-    "InitiativeBonus": 0,
+-    "PassivePerception": 12
+-  },
+-  {
+-    "Name": "Anakin Skywalker",
+-    "Race": "human",
+-    "Background": "acolyte",
+-    "Class": "warlock",
+-    "Level": 20,
+-    "Proficiency": 6,
+-    "Stats": {
+-      "Str": 13,
+-      "StrMod": 1,
+-      "Dex": 9,
+-      "DexMod": -1,
+-      "Con": 15,
+-      "ConMod": 2,
+-      "Intel": 14,
+-      "IntelMod": 2,
+-      "Wis": 11,
+-      "WisMod": 0,
+-      "Cha": 16,
+-      "ChaMod": 3
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "arcana",
+-        "deception",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": [
+-        "padded",
+-        "leather",
+-        "studded leather"
+-      ],
+-      "Shields": "",
+-      "Weapons": null,
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": "dagger"
+-      },
+-      "Armor": "",
+-      "Shield": ""
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 4,
+-      "SpellsKnown": 0,
+-      "CanCast": true,
+-      "CasterType": "pact",
+-      "learned_spells": [],
+-      "prepared_spells": [],
+-      "slots": {
+-        "5": 4
+-      },
+-      "maxslots": {
+-        "5": 4
+-      },
+-      "PreparedMode": false,
+-      "LearnedMode": false,
+-      "Ability": "charisma",
+-      "SpellSaveDC": 17,
+-      "SpellAttackBonus": 9
+-    },
+-    "ArmorClass": 9,
+-    "InitiativeBonus": -1,
+-    "PassivePerception": 10
+-  },
+-  {
+-    "Name": "Kaelen Swiftstep",
+-    "Race": "human",
+-    "Background": "acolyte",
+-    "Class": "rogue",
+-    "Level": 1,
+-    "Proficiency": 2,
+-    "Stats": {
+-      "Str": 11,
+-      "StrMod": 0,
+-      "Dex": 16,
+-      "DexMod": 3,
+-      "Con": 15,
+-      "ConMod": 2,
+-      "Intel": 13,
+-      "IntelMod": 1,
+-      "Wis": 14,
+-      "WisMod": 2,
+-      "Cha": 9,
+-      "ChaMod": -1
+-    },
+-    "Skills": {
+-      "MaxAllowed": 4,
+-      "Skills": [
+-        "acrobatics",
+-        "athletics",
+-        "deception",
+-        "insight",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": [
+-        "padded",
+-        "leather",
+-        "studded leather"
+-      ],
+-      "Shields": "",
+-      "Weapons": [
+-        {
+-          "Name": "hand crossbow",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "longsword",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "rapier",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        },
+-        {
+-          "Name": "shortsword",
+-          "Category": "",
+-          "Range": 0,
+-          "TwoHanded": false
+-        }
+-      ],
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "leather armor",
+-      "Shield": ""
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 0,
+-      "SpellsKnown": 0,
+-      "CanCast": false,
+-      "CasterType": "",
+-      "learned_spells": [],
+-      "prepared_spells": [],
+-      "slots": {},
+-      "maxslots": {},
+-      "PreparedMode": false,
+-      "LearnedMode": false,
+-      "Ability": "",
+-      "SpellSaveDC": 0,
+-      "SpellAttackBonus": 0
+-    },
+-    "ArmorClass": 14,
+-    "InitiativeBonus": 3,
+-    "PassivePerception": 12
+-  },
+-  {
+-    "Name": "Thorga Stonehand",
+-    "Race": "hill dwarf",
+-    "Background": "acolyte",
+-    "Class": "fighter",
+-    "Level": 1,
+-    "Proficiency": 2,
+-    "Stats": {
+-      "Str": 15,
+-      "StrMod": 2,
+-      "Dex": 12,
+-      "DexMod": 1,
+-      "Con": 16,
+-      "ConMod": 3,
+-      "Intel": 8,
+-      "IntelMod": -1,
+-      "Wis": 14,
+-      "WisMod": 2,
+-      "Cha": 10,
+-      "ChaMod": 0
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "acrobatics",
+-        "animal handling",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": [
+-        "padded",
+-        "leather",
+-        "studded leather",
+-        "hide",
+-        "chain shirt",
+-        "scale mail",
+-        "breast plate",
+-        "half plate",
+-        "ring mail",
+-        "chain mail",
+-        "splint",
+-        "plate"
+-      ],
+-      "Shields": "shield",
+-      "Weapons": null,
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "scale mail",
+-      "Shield": "shield"
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 0,
+-      "SpellsKnown": 0,
+-      "CanCast": false,
+-      "CasterType": "",
+-      "learned_spells": [],
+-      "prepared_spells": [],
+-      "slots": {},
+-      "maxslots": {},
+-      "PreparedMode": false,
+-      "LearnedMode": false,
+-      "Ability": "",
+-      "SpellSaveDC": 0,
+-      "SpellAttackBonus": 0
+-    },
+-    "ArmorClass": 17,
+-    "InitiativeBonus": 1,
+-    "PassivePerception": 12
+-  },
+-  {
+-    "Name": "Ragna Wolfblood",
+-    "Race": "half orc",
+-    "Background": "acolyte",
+-    "Class": "barbarian",
+-    "Level": 1,
+-    "Proficiency": 2,
+-    "Stats": {
+-      "Str": 17,
+-      "StrMod": 3,
+-      "Dex": 14,
+-      "DexMod": 2,
+-      "Con": 14,
+-      "ConMod": 2,
+-      "Intel": 8,
+-      "IntelMod": -1,
+-      "Wis": 12,
+-      "WisMod": 1,
+-      "Cha": 10,
+-      "ChaMod": 0
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "animal handling",
+-        "athletics",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": [
+-        "padded",
+-        "leather",
+-        "studded leather",
+-        "hide",
+-        "chain shirt",
+-        "scale mail",
+-        "breast plate",
+-        "half plate"
+-      ],
+-      "Shields": "shield",
+-      "Weapons": null,
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "",
+-      "Shield": ""
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 0,
+-      "SpellsKnown": 0,
+-      "CanCast": false,
+-      "CasterType": "",
+-      "learned_spells": [],
+-      "prepared_spells": [],
+-      "slots": {},
+-      "maxslots": {},
+-      "PreparedMode": false,
+-      "LearnedMode": false,
+-      "Ability": "",
+-      "SpellSaveDC": 0,
+-      "SpellAttackBonus": 0
+-    },
+-    "ArmorClass": 14,
+-    "InitiativeBonus": 2,
+-    "PassivePerception": 11
+-  },
+-  {
+-    "Name": "Gorrak Bearhide",
+-    "Race": "human",
+-    "Background": "acolyte",
+-    "Class": "barbarian",
+-    "Level": 1,
+-    "Proficiency": 2,
+-    "Stats": {
+-      "Str": 16,
+-      "StrMod": 3,
+-      "Dex": 14,
+-      "DexMod": 2,
+-      "Con": 15,
+-      "ConMod": 2,
+-      "Intel": 9,
+-      "IntelMod": -1,
+-      "Wis": 13,
+-      "WisMod": 1,
+-      "Cha": 11,
+-      "ChaMod": 0
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "animal handling",
+-        "athletics",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": [
+-        "padded",
+-        "leather",
+-        "studded leather",
+-        "hide",
+-        "chain shirt",
+-        "scale mail",
+-        "breast plate",
+-        "half plate"
+-      ],
+-      "Shields": "shield",
+-      "Weapons": null,
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "",
+-      "Shield": "shield"
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 0,
+-      "SpellsKnown": 0,
+-      "CanCast": false,
+-      "CasterType": "",
+-      "learned_spells": [],
+-      "prepared_spells": [],
+-      "slots": {},
+-      "maxslots": {},
+-      "PreparedMode": false,
+-      "LearnedMode": false,
+-      "Ability": "",
+-      "SpellSaveDC": 0,
+-      "SpellAttackBonus": 0
+-    },
+-    "ArmorClass": 16,
+-    "InitiativeBonus": 2,
+-    "PassivePerception": 11
+-  },
+-  {
+-    "Name": "Brynja Axebreaker",
+-    "Race": "human",
+-    "Background": "acolyte",
+-    "Class": "barbarian",
+-    "Level": 1,
+-    "Proficiency": 2,
+-    "Stats": {
+-      "Str": 16,
+-      "StrMod": 3,
+-      "Dex": 14,
+-      "DexMod": 2,
+-      "Con": 15,
+-      "ConMod": 2,
+-      "Intel": 9,
+-      "IntelMod": -1,
+-      "Wis": 13,
+-      "WisMod": 1,
+-      "Cha": 11,
+-      "ChaMod": 0
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "animal handling",
+-        "athletics",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": [
+-        "padded",
+-        "leather",
+-        "studded leather",
+-        "hide",
+-        "chain shirt",
+-        "scale mail",
+-        "breast plate",
+-        "half plate"
+-      ],
+-      "Shields": "shield",
+-      "Weapons": null,
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "",
+-      "Shield": "shield"
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 0,
+-      "SpellsKnown": 0,
+-      "CanCast": false,
+-      "CasterType": "",
+-      "learned_spells": [],
+-      "prepared_spells": [],
+-      "slots": {},
+-      "maxslots": {},
+-      "PreparedMode": false,
+-      "LearnedMode": false,
+-      "Ability": "",
+-      "SpellSaveDC": 0,
+-      "SpellAttackBonus": 0
+-    },
+-    "ArmorClass": 16,
+-    "InitiativeBonus": 2,
+-    "PassivePerception": 11
+-  },
+-  {
+-    "Name": "Qui-Gon Jinn",
+-    "Race": "human",
+-    "Background": "acolyte",
+-    "Class": "cleric",
+-    "Level": 10,
+-    "Proficiency": 4,
+-    "Stats": {
+-      "Str": 15,
+-      "StrMod": 2,
+-      "Dex": 9,
+-      "DexMod": -1,
+-      "Con": 11,
+-      "ConMod": 0,
+-      "Intel": 14,
+-      "IntelMod": 2,
+-      "Wis": 16,
+-      "WisMod": 3,
+-      "Cha": 13,
+-      "ChaMod": 1
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "history",
+-        "insight",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": [
+-        "padded",
+-        "leather",
+-        "studded leather",
+-        "hide",
+-        "chain shirt",
+-        "scale mail",
+-        "breast plate",
+-        "half plate"
+-      ],
+-      "Shields": "shield",
+-      "Weapons": null,
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "",
+-      "Shield": ""
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 5,
+-      "SpellsKnown": 0,
+-      "CanCast": true,
+-      "CasterType": "full",
+-      "learned_spells": [],
+-      "prepared_spells": [],
+-      "slots": {
+-        "1": 4,
+-        "2": 3,
+-        "3": 3,
+-        "4": 3,
+-        "5": 2
+-      },
+-      "maxslots": {
+-        "1": 4,
+-        "2": 3,
+-        "3": 3,
+-        "4": 3,
+-        "5": 2
+-      },
+-      "PreparedMode": false,
+-      "LearnedMode": false,
+-      "Ability": "wisdom",
+-      "SpellSaveDC": 15,
+-      "SpellAttackBonus": 7
+-    },
+-    "ArmorClass": 9,
+-    "InitiativeBonus": -1,
+-    "PassivePerception": 13
+-  },
+-  {
+-    "Name": "Branric Ironwall",
+-    "Race": "human",
+-    "Background": "acolyte",
+-    "Class": "paladin",
+-    "Level": 1,
+-    "Proficiency": 2,
+-    "Stats": {
+-      "Str": 16,
+-      "StrMod": 3,
+-      "Dex": 9,
+-      "DexMod": -1,
+-      "Con": 15,
+-      "ConMod": 2,
+-      "Intel": 11,
+-      "IntelMod": 0,
+-      "Wis": 13,
+-      "WisMod": 1,
+-      "Cha": 14,
+-      "ChaMod": 2
+-    },
+-    "Skills": {
+-      "MaxAllowed": 2,
+-      "Skills": [
+-        "athletics",
+-        "insight",
+-        "insight",
+-        "religion"
+-      ],
+-      "Armor": [
+-        "padded",
+-        "leather",
+-        "studded leather",
+-        "hide",
+-        "chain shirt",
+-        "scale mail",
+-        "breast plate",
+-        "half plate",
+-        "ring mail",
+-        "chain mail",
+-        "splint",
+-        "plate"
+-      ],
+-      "Shields": "shield",
+-      "Weapons": null,
+-      "MainHand": "main hand",
+-      "OffHand": "off hand"
+-    },
+-    "Equipment": {
+-      "Weapon": {
+-        "main hand": "",
+-        "off hand": ""
+-      },
+-      "Armor": "plate armor",
+-      "Shield": "shield"
+-    },
+-    "Spellcasting": {
+-      "CantripsKnown": 0,
+-      "SpellsKnown": 0,
+-      "CanCast": false,
+-      "CasterType": "half",
+-      "learned_spells": [],
+-      "prepared_spells": [],
+-      "slots": {},
+-      "maxslots": {},
+-      "PreparedMode": false,
+-      "LearnedMode": false,
+-      "Ability": "",
+-      "SpellSaveDC": 0,
+-      "SpellAttackBonus": 0
+-    },
+-    "ArmorClass": 20,
+-    "InitiativeBonus": -1,
+-    "PassivePerception": 11
+-  }
+-]
+\ No newline at end of file
+diff --git a/domain/character.go b/domain/character.go
+index ab8e217..b5b6564 100644
+--- a/domain/character.go
++++ b/domain/character.go
+@@ -1,17 +1,6 @@
+ package domain
+ 
+-var SpellcastingType = map[string]string{
+-	"bard":     "full",
+-	"cleric":   "full",
+-	"druid":    "full",
+-	"sorcerer": "full",
+-	"wizard":   "full",
+-
+-	"paladin": "half",
+-	"ranger":  "half",
+-
+-	"warlock": "pact",
+-}
++import "strings"
+ 
+ type Character struct {
+ 	Name              string
+@@ -29,75 +18,95 @@ type Character struct {
+ 	PassivePerception int
+ }
+ 
+-type ClassLoadout struct {
+-	MaxAllowed int
+-	Skills     []string
+-	Armor      []string
+-	Shields    string
+-	Weapons    []WeaponInfo
+-	MainHand   string
+-	OffHand    string
+-}
+-
+-type Stats struct {
+-	Str    int
+-	StrMod int
+-
+-	Dex    int
+-	DexMod int
+-
+-	Con    int
+-	ConMod int
+-
+-	Intel    int
+-	IntelMod int
+-
+-	Wis    int
+-	WisMod int
+-
+-	Cha    int
+-	ChaMod int
+-}
+-
+-type Equipment struct {
+-	Weapon map[string]string
+-	Armor  string
+-	Shield string
+-}
+-
+-type Spellcasting struct {
+-	CantripsKnown    int
+-	SpellsKnown      int
+-	CanCast          bool
+-	CasterType       string
+-	LearnedSpells    []string    `json:"learned_spells"`
+-	PreparedSpells   []string    `json:"prepared_spells"`
+-	Slots            map[int]int `json:"slots"`
+-	MaxSlots         map[int]int `json:"maxslots"`
+-	PreparedMode     bool
+-	LearnedMode      bool
+-	Ability          string
+-	SpellSaveDC      int
+-	SpellAttackBonus int
+-}
+-
+-type SpellInfo struct {
+-	Name   string `json:"name"`
+-	Level  int    `json:"level"`
+-	School string `json:"school"`
+-	Range  string `json:"range"`
++func (c *Character) UpdateProficiency() {
++	switch {
++	case c.Level >= 17:
++		c.Proficiency = 6
++	case c.Level >= 13:
++		c.Proficiency = 5
++	case c.Level >= 9:
++		c.Proficiency = 4
++	case c.Level >= 5:
++		c.Proficiency = 3
++	default:
++		c.Proficiency = 2
++	}
++
++	c.Stats.StrMod = abilityModifier(c.Stats.Str)
++	c.Stats.DexMod = abilityModifier(c.Stats.Dex)
++	c.Stats.ConMod = abilityModifier(c.Stats.Con)
++	c.Stats.IntelMod = abilityModifier(c.Stats.Intel)
++	c.Stats.WisMod = abilityModifier(c.Stats.Wis)
++	c.Stats.ChaMod = abilityModifier(c.Stats.Cha)
+ }
+ 
+-type WeaponInfo struct {
+-	Name      string
+-	Category  string
+-	Range     int
+-	TwoHanded bool
++func (c *Character) ApplyRacialBonuses() {
++	race := strings.ToLower(strings.ReplaceAll(c.Race, " ", "-"))
++	switch race {
++	case "dwarf":
++		c.Stats.Con += 2
++
++	case "hill-dwarf":
++		c.Stats.Con += 2
++		c.Stats.Wis += 1
++
++	case "elf":
++		c.Stats.Dex += 2
++
++	case "halfling", "stout-halfling":
++		c.Stats.Dex += 2
++
++	case "lightfoot-halfling":
++		c.Stats.Dex += 2
++		c.Stats.Cha++
++
++	case "human":
++		c.Stats.Str++
++		c.Stats.Dex++
++		c.Stats.Con++
++		c.Stats.Intel++
++		c.Stats.Wis++
++		c.Stats.Cha++
++
++	case "dragonborn":
++		c.Stats.Str += 2
++		c.Stats.Cha++
++
++	case "gnome":
++		c.Stats.Intel += 2
++
++	// TODO: half-eelves get to choose which stats to increase besides the rizz, for now dex and wis as defaults
++	case "half-elf":
++		c.Stats.Cha += 2
++		c.Stats.Dex++
++		c.Stats.Wis++
++
++	case "half-orc":
++		c.Stats.Str += 2
++		c.Stats.Con++
++
++	case "tiefling":
++		c.Stats.Cha += 2
++		c.Stats.Intel++
++	}
++
++	c.UpdateProficiency()
+ }
+ 
+-type ArmorInfo struct {
+-	Name     string
+-	BaseAC   int
+-	DexBonus bool
+-	MaxBonus int
++func SanitizeLocalKey(name string) string {
++	key := strings.ToLower(name)
++	key = strings.ReplaceAll(key, "'", "")
++	key = strings.ReplaceAll(key, "â€™", "")
++	key = strings.ReplaceAll(key, "(", "")
++	key = strings.ReplaceAll(key, ")", "")
++	key = strings.ReplaceAll(key, ",", "")
++	key = strings.ReplaceAll(key, "/", "-")
++	key = strings.ReplaceAll(key, ":", "")
++	key = strings.ReplaceAll(key, ".", "")
++	key = strings.ReplaceAll(key, " ", "-")
++	key = strings.ReplaceAll(key, " ", "-")
++	key = strings.TrimSuffix(key, "-armor")
++	key = strings.TrimSuffix(key, " armor")
++	key = strings.TrimSpace(key)
++	return key
+ }
+diff --git a/domain/character_new.go b/domain/character_new.go
+new file mode 100644
+index 0000000..fb645d5
+--- /dev/null
++++ b/domain/character_new.go
+@@ -0,0 +1,36 @@
++package domain
++
++import "fmt"
++
++func NewCharacter(name, race, background, class string, level int, stats Stats) (*Character, error) {
++	if name == "" {
++		return nil, fmt.Errorf("character name is required")
++	}
++	if race == "" {
++		return nil, fmt.Errorf("character race is required")
++	}
++	if class == "" {
++		return nil, fmt.Errorf("character class is required")
++	}
++	if level <= 0 {
++		return nil, fmt.Errorf("character level must be > 0")
++	}
++
++	c := &Character{
++		Name:       name,
++		Race:       race,
++		Background: background,
++		Class:      class,
++		Level:      level,
++		Stats:      stats,
++		Equipment: Equipment{
++			Weapon: map[string]string{"main hand": "", "off hand": ""},
++			Armor:  "",
++			Shield: "",
++		},
++	}
++
++	c.ApplyRacialBonuses()
++
++	return c, nil
++}
+diff --git a/domain/class/classes.go b/domain/class/classes.go
+new file mode 100644
+index 0000000..23c6347
+--- /dev/null
++++ b/domain/class/classes.go
+@@ -0,0 +1,265 @@
++package class
++
++import (
++	"strings"
++
++	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
++)
++
++type ClassRepository struct {
++	all     []domain.WeaponInfo
++	simple  []domain.WeaponInfo
++	martial []domain.WeaponInfo
++
++	classes map[string]ClassSkills
++}
++
++type ClassSkills struct {
++	MaxAllowed int
++	Skills     []string
++	Armor      []string
++	Shields    string
++	Weapons    []domain.WeaponInfo
++	MainHand   string
++	OffHand    string
++}
++
++func NewClassRepository(all, simple, martial []domain.WeaponInfo) *ClassRepository {
++	cr := &ClassRepository{
++		all:     append([]domain.WeaponInfo{}, all...),
++		simple:  append([]domain.WeaponInfo{}, simple...),
++		martial: append([]domain.WeaponInfo{}, martial...),
++	}
++	cr.classes = cr.buildClasses()
++	return cr
++}
++
++func (r *ClassRepository) Get(className string) (ClassSkills, bool) {
++	key := strings.ToLower(strings.TrimSpace(className))
++	cs, ok := r.classes[key]
++	return cs, ok
++}
++
++func (r *ClassRepository) findByName(name string) (domain.WeaponInfo, bool) {
++	lo := strings.ToLower(strings.TrimSpace(name))
++	for _, w := range r.all {
++		if strings.EqualFold(strings.TrimSpace(w.Name), lo) {
++			return w, true
++		}
++	}
++	return domain.WeaponInfo{Name: name}, false
++}
++
++func (r *ClassRepository) CombineWeaponSets(sets ...[]domain.WeaponInfo) []domain.WeaponInfo {
++	out := make([]domain.WeaponInfo, 0)
++	for _, s := range sets {
++		out = append(out, s...)
++	}
++	return out
++}
++
++func (r *ClassRepository) withExtra(base []domain.WeaponInfo, names ...string) []domain.WeaponInfo {
++	out := append([]domain.WeaponInfo{}, base...)
++	for _, n := range names {
++		if w, ok := r.findByName(n); ok {
++			out = append(out, w)
++		} else {
++			out = append(out, domain.WeaponInfo{Name: n})
++		}
++	}
++	return out
++}
++
++func (r *ClassRepository) WeaponsByName(names ...string) []domain.WeaponInfo {
++	out := make([]domain.WeaponInfo, 0, len(names))
++	for _, n := range names {
++		if w, ok := r.findByName(n); ok {
++			out = append(out, w)
++		} else {
++			out = append(out, domain.WeaponInfo{Name: n})
++		}
++	}
++	return out
++}
++
++func (r *ClassRepository) weaponOrFallback(name string) domain.WeaponInfo {
++	if w, ok := r.findByName(name); ok {
++		return w
++	}
++	return domain.WeaponInfo{Name: name}
++}
++
++func (r *ClassRepository) buildClasses() map[string]ClassSkills {
++	return map[string]ClassSkills{
++		"barbarian": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"animal handling", "athletics", "intimidation", "nature", "perception", "survival",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
++			},
++			Shields:  "shield",
++			Weapons:  r.all,
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"bard": {
++			MaxAllowed: 3,
++			Skills: []string{
++				"acrobatics", "animal handling", "arcana", "athletics", "deception",
++				"history", "insight", "intimidation", "investigation", "medicine", "nature",
++				"perception", "performance", "persuasion", "religion", "sleight of hand", "stealth", "survival",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather",
++			},
++			Weapons: r.withExtra(
++				r.simple,
++				"hand crossbow", "longsword", "rapier", "shortsword",
++			),
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"cleric": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"history", "insight", "medicine", "persuasion", "religion",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
++			},
++			Shields:  "shield",
++			Weapons:  r.simple,
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"druid": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"arcana", "animal handling", "insight", "medicine", "nature", "perception", "religion", "survival",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
++			},
++			Shields: "shield",
++			Weapons: append(r.simple,
++				r.weaponOrFallback("club"),
++				r.weaponOrFallback("greatclub"),
++				r.weaponOrFallback("dagger"),
++				r.weaponOrFallback("dart"),
++				r.weaponOrFallback("javelins"),
++				r.weaponOrFallback("maces"),
++				r.weaponOrFallback("quarterstaff"),
++				r.weaponOrFallback("scimitar"),
++				r.weaponOrFallback("sickle"),
++				r.weaponOrFallback("sling"),
++				r.weaponOrFallback("spear"),
++			),
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"fighter": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"acrobatics", "animal handling", "athletics", "history", "insight", "intimidation", "perception", "survival",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate", "ring mail", "chain mail", "splint", "plate",
++			},
++			Shields:  "shield",
++			Weapons:  r.simple,
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"monk": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"acrobatics", "athletics", "history", "insight", "religion", "stealth",
++			},
++			// NO ARMOR
++			Weapons: append(r.simple,
++				r.weaponOrFallback("shortsword"),
++			),
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"paladin": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"athletics", "insight", "intimidation", "medicine", "persuasion", "religion",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate", "ring mail", "chain mail", "splint", "plate",
++			},
++			Shields:  "shield",
++			Weapons:  r.all,
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"ranger": {
++			MaxAllowed: 3,
++			Skills: []string{
++				"animal handling", "athletics", "insight", "investigation", "nature", "perception", "stealth", "survival",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather", "hide", "chain shirt", "scale mail", "breast plate", "half plate",
++			},
++			Shields:  "shield",
++			Weapons:  r.all,
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"rogue": {
++			MaxAllowed: 4,
++			Skills: []string{
++				"acrobatics", "athletics", "deception", "insight", "intimidation", "investigation", "perception", "performance", "persuasion", "sleight of hand", "stealth",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather",
++			},
++			Weapons: r.withExtra(
++				r.simple,
++				"hand crossbow", "longsword", "rapier", "shortsword",
++			),
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"sorcerer": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"arcana", "deception", "insight", "intimidation", "persuasion", "religion",
++			},
++			// NO ARMOR
++			Weapons: r.WeaponsByName(
++				"dagger", "dart", "sling", "quarterstaff", "light crossbow",
++			),
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"warlock": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"arcana", "deception", "history", "intimidation", "investigation", "nature", "religion",
++			},
++			Armor: []string{
++				"padded", "leather", "studded leather",
++			},
++			Weapons:  r.simple,
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++		"wizard": {
++			MaxAllowed: 2,
++			Skills: []string{
++				"arcana", "history", "insight", "investigation", "medicine", "religion",
++			},
++			// NO ARMOR
++			Weapons: r.WeaponsByName(
++				"dagger", "dart", "sling", "quarterstaff", "light crossbow",
++			),
++			MainHand: "main hand",
++			OffHand:  "off hand",
++		},
++	}
++}
+diff --git a/domain/class_loadout.go b/domain/class_loadout.go
+new file mode 100644
+index 0000000..f51027e
+--- /dev/null
++++ b/domain/class_loadout.go
+@@ -0,0 +1,11 @@
++package domain
++
++type ClassLoadout struct {
++	MaxAllowed int
++	Skills     []string
++	Armor      []string
++	Shields    string
++	Weapons    []WeaponInfo
++	MainHand   string
++	OffHand    string
++}
+diff --git a/service/combat_stats.go b/domain/equipment.go
+similarity index 53%
+rename from service/combat_stats.go
+rename to domain/equipment.go
+index 5ce01b8..dbb85e0 100644
+--- a/service/combat_stats.go
++++ b/domain/equipment.go
+@@ -1,11 +1,16 @@
+-package service
++package domain
+ 
+ import (
++	"errors"
+ 	"strings"
+-
+-	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+ )
+ 
++type Equipment struct {
++	Weapon map[string]string
++	Armor  string
++	Shield string
++}
++
+ type ArmorInfo struct {
+ 	BaseAC   int
+ 	DexBonus string
+@@ -29,11 +34,71 @@ var ArmorData = map[string]ArmorInfo{
+ 	"plate":      {BaseAC: 18, DexBonus: "none", Category: "heavy"},
+ }
+ 
+-func CalculateInitiative(s *domain.Stats) int {
+-	return s.DexMod
++var (
++	ErrSlotOccupied = errors.New("slot already occupied")
++	ErrInvalidSlot  = errors.New("invalid slot")
++	ErrNoWeaponName = errors.New("weapon name cannot be empty")
++	ErrNoArmorName  = errors.New("armor name cannot be empty")
++	ErrNoShieldName = errors.New("shield name cannot be empty")
++)
++
++func (c *Character) EquipWeapon(slot, weapon string) error {
++	slot = strings.ToLower(strings.TrimSpace(slot))
++	if weapon == "" {
++		return ErrNoWeaponName
++	}
++
++	if slot != "main hand" && slot != "off hand" {
++		return ErrInvalidSlot
++	}
++
++	if c.Equipment.Weapon == nil {
++		c.Equipment.Weapon = make(map[string]string)
++	}
++
++	if existing, ok := c.Equipment.Weapon[slot]; ok && existing != "" {
++		return ErrSlotOccupied
++	}
++
++	c.Equipment.Weapon[slot] = weapon
++	return nil
++}
++
++func (c *Character) EquipArmor(armor string) error {
++	if armor == "" {
++		return ErrNoArmorName
++	}
++
++	c.Equipment.Armor = armor
++	return nil
++}
++
++func (c *Character) EquipShield(shield string) error {
++	if shield == "" {
++		return ErrNoShieldName
++	}
++
++	c.Equipment.Shield = shield
++	return nil
++}
++
++func (c *Character) CalculateInitiative() int {
++	return c.Stats.DexMod
++}
++
++func (c *Character) CalculatePassivePerception() int {
++	base := 10 + c.Stats.WisMod
++
++	for _, skill := range c.Skills.Skills {
++		if skill == "perception" {
++			base += c.Proficiency
++			break
++		}
++	}
++	return base
+ }
+ 
+-func CalculateArmorClass(c *domain.Character) int {
++func (c *Character) CalculateArmorClass() int {
+ 	s := &c.Stats
+ 	e := &c.Equipment
+ 	class := strings.ToLower(c.Class)
+@@ -55,7 +120,7 @@ func CalculateArmorClass(c *domain.Character) int {
+ 				}
+ 				ac += dex
+ 			case "none":
+-				// no bolus
++				// no bonus
+ 			}
+ 		}
+ 
+diff --git a/domain/repository.go b/domain/repository.go
+new file mode 100644
+index 0000000..578039e
+--- /dev/null
++++ b/domain/repository.go
+@@ -0,0 +1,8 @@
++package domain
++
++type Repository interface {
++	Save(character *Character) error
++	Load(name string) (*Character, error)
++	List() ([]*Character, error)
++	Delete(name string) error
++}
+diff --git a/domain/spellcast.go b/domain/spellcast.go
+new file mode 100644
+index 0000000..3628ca1
+--- /dev/null
++++ b/domain/spellcast.go
+@@ -0,0 +1,39 @@
++package domain
++
++import "strings"
++
++type Spellcasting struct {
++	CantripsKnown    int
++	SpellsKnown      int
++	CanCast          bool
++	CasterType       string
++	LearnedSpells    []string    `json:"learned_spells"`
++	PreparedSpells   []string    `json:"prepared_spells"`
++	Slots            map[int]int `json:"slots"`
++	MaxSlots         map[int]int `json:"maxslots"`
++	PreparedMode     bool
++	LearnedMode      bool
++	Ability          string
++	SpellSaveDC      int
++	SpellAttackBonus int
++}
++
++type SpellInfo struct {
++	Name   string `json:"name"`
++	Level  int    `json:"level"`
++	School string `json:"school"`
++	Range  string `json:"range"`
++}
++
++func GetSpellcastingType(class string) string {
++	switch strings.ToLower(class) {
++	case "bard", "cleric", "druid", "sorcerer", "wizard":
++		return "full"
++	case "paladin", "ranger":
++		return "half"
++	case "warlock":
++		return "pact"
++	default:
++		return ""
++	}
++}
+diff --git a/domain/stats.go b/domain/stats.go
+new file mode 100644
+index 0000000..76f2ce7
+--- /dev/null
++++ b/domain/stats.go
+@@ -0,0 +1,29 @@
++package domain
++
++type Stats struct {
++	Str    int
++	StrMod int
++
++	Dex    int
++	DexMod int
++
++	Con    int
++	ConMod int
++
++	Intel    int
++	IntelMod int
++
++	Wis    int
++	WisMod int
++
++	Cha    int
++	ChaMod int
++}
++
++func abilityModifier(score int) int {
++	result := (score - 10) / 2
++	if (score-10)%2 < 0 {
++		result--
++	}
++	return result
++}
+diff --git a/domain/weapon_info.go b/domain/weapon_info.go
+new file mode 100644
+index 0000000..30d555b
+--- /dev/null
++++ b/domain/weapon_info.go
+@@ -0,0 +1,8 @@
++package domain
++
++type WeaponInfo struct {
++	Name      string
++	Category  string
++	Range     int
++	TwoHanded bool
++}
+diff --git a/main.go b/main.go
+index 0b986b0..cf52e1a 100755
+--- a/main.go
++++ b/main.go
+@@ -6,12 +6,11 @@ import (
+ 	"log"
+ 	"net/http"
+ 	"os"
+-	"strings"
+ 
+ 	"path/filepath"
+ 
+-	"github.com/DanielBartha/MPP-DnD-Character-Gen/characterClasses"
+ 	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
++	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain/class"
+ 	"github.com/DanielBartha/MPP-DnD-Character-Gen/repository"
+ 	"github.com/DanielBartha/MPP-DnD-Character-Gen/service"
+ )
+@@ -51,8 +50,6 @@ func main() {
+ 	simple := service.SimpleWeapons(allWeps)
+ 	martial := service.MartialWeapons(allWeps)
+ 
+-	characterClasses.InitWeapons(allWeps, simple, martial)
+-
+ 	switch cmd {
+ 	case "create":
+ 		createCmd := flag.NewFlagSet("create", flag.ExitOnError)
+@@ -61,7 +58,7 @@ func main() {
+ 		race := createCmd.String("race", "", "character race (required)")
+ 		// "acolyte" default
+ 		background := createCmd.String("background", "acolyte", "character background (required)")
+-		class := createCmd.String("class", "", "character class (required)")
++		className := createCmd.String("class", "", "character class (required)")
+ 		level := createCmd.Int("level", 1, "character level (required)")
+ 
+ 		str := createCmd.Int("str", 10, "strength is required")
+@@ -71,69 +68,31 @@ func main() {
+ 		wis := createCmd.Int("wis", 10, "wisdom is required")
+ 		cha := createCmd.Int("cha", 10, "charisma is required")
+ 
+-		err := createCmd.Parse(os.Args[2:])
+-		if err != nil {
+-			fmt.Println("error parsing flags")
+-			createCmd.Usage()
+-			os.Exit(2)
+-		}
+-
+-		if *name == "" {
+-			fmt.Println("name is required")
+-			os.Exit(2)
+-		}
+-		if *race == "" {
+-			fmt.Println("race is required")
+-			os.Exit(2)
+-		}
+-		if *class == "" {
+-			fmt.Println("class is required")
+-			os.Exit(2)
+-		}
+-		if *level <= 0 {
+-			fmt.Println("level is required")
++		if err := createCmd.Parse(os.Args[2:]); err != nil {
++			fmt.Println("error parsing flags:", err)
+ 			os.Exit(2)
+ 		}
+ 
+-		characterCreate := domain.Character{
+-			Name:       *name,
+-			Race:       *race,
+-			Background: *background,
+-			Class:      *class,
+-			Level:      *level,
+-			Stats: domain.Stats{
+-				Str:   *str,
+-				Dex:   *dex,
+-				Con:   *con,
+-				Intel: *intel,
+-				Wis:   *wis,
+-				Cha:   *cha,
+-			},
++		stats := domain.Stats{
++			Str: *str, Dex: *dex, Con: *con, Intel: *intel, Wis: *wis, Cha: *cha,
+ 		}
+ 
+-		svc := service.NewCharacterService()
+-
+-		characterCreate.Skills = svc.GetClassSkills(&characterCreate)
+-		svc.ApplyRacialBonuses(&characterCreate)
+-		svc.UpdateProficiency(&characterCreate)
+-		svc.InitSpellcasting(&characterCreate)
+-
+-		characterCreate.Equipment = domain.Equipment{
+-			Weapon: map[string]string{
+-				"main hand": "",
+-				"off hand":  "",
+-			},
+-			Armor:  "",
+-			Shield: "",
++		char, err := domain.NewCharacter(*name, *race, *background, *className, *level, stats)
++		if err != nil {
++			fmt.Println("Error creating character:", err)
++			os.Exit(2)
+ 		}
+ 
+ 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
+-		if err := repo.Save(&characterCreate); err != nil {
+-			fmt.Println("error saving character:", err)
++		classRepo := class.NewClassRepository(allWeps, simple, martial)
++		facade := service.NewCharacterFacade(repo, classRepo)
++
++		if err := facade.CreateCharacter(char); err != nil {
++			fmt.Println("Error creating character: ", err)
+ 			os.Exit(2)
+ 		}
+ 
+-		fmt.Printf("saved character %+v\n", characterCreate.Name)
++		fmt.Printf("saved character %s\n", char.Name)
+ 
+ 	case "view":
+ 		viewCmd := flag.NewFlagSet("view", flag.ExitOnError)
+@@ -146,93 +105,32 @@ func main() {
+ 		}
+ 
+ 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
+-		character, err := repo.Load(*name)
++		facade := service.NewCharacterFacade(repo, nil)
++
++		char, err := facade.ViewCharacter(*name)
+ 		if err != nil {
+ 			fmt.Printf("character %q not found\n", *name)
+ 			return
+ 		}
+ 
+-		fmt.Printf(
+-			"Name: %s\n"+
+-				"Class: %s\n"+
+-				"Race: %s\n"+
+-				"Background: %s\n"+
+-				"Level: %d\n"+
+-				"Ability scores:\n"+
+-				"  STR: %d (%+d)\n"+
+-				"  DEX: %d (%+d)\n"+
+-				"  CON: %d (%+d)\n"+
+-				"  INT: %d (%+d)\n"+
+-				"  WIS: %d (%+d)\n"+
+-				"  CHA: %d (%+d)\n"+
+-				"Proficiency bonus: +%d\n"+
+-				"Skill proficiencies: %s\n",
+-			character.Name,
+-			strings.ToLower(character.Class),
+-			strings.ToLower(character.Race),
+-			character.Background,
+-			character.Level,
+-			character.Stats.Str, character.Stats.StrMod,
+-			character.Stats.Dex, character.Stats.DexMod,
+-			character.Stats.Con, character.Stats.ConMod,
+-			character.Stats.Intel, character.Stats.IntelMod,
+-			character.Stats.Wis, character.Stats.WisMod,
+-			character.Stats.Cha, character.Stats.ChaMod,
+-			character.Proficiency,
+-			strings.Join(character.Skills.Skills, ", "),
+-		)
+-
+-		if character.Spellcasting != nil && character.Spellcasting.CanCast {
+-			fmt.Println("Spell slots:")
+-
+-			if character.Spellcasting.CantripsKnown > 0 {
+-				fmt.Printf("  Level 0: %d\n", character.Spellcasting.CantripsKnown)
+-			}
+-
+-			for lvl := 1; lvl <= 9; lvl++ {
+-				if count, ok := character.Spellcasting.MaxSlots[lvl]; ok && count > 0 {
+-					fmt.Printf("  Level %d: %d\n", lvl, count)
+-				}
+-			}
+-
+-			if character.Spellcasting.Ability != "" {
+-				fmt.Printf("Spellcasting ability: %s\n", strings.ToLower(character.Spellcasting.Ability))
+-				fmt.Printf("Spell save DC: %d\n", character.Spellcasting.SpellSaveDC)
+-				fmt.Printf("Spell attack bonus: +%d\n", character.Spellcasting.SpellAttackBonus)
+-			}
+-		}
+-
+-		if weapon, ok := character.Equipment.Weapon["main hand"]; ok && weapon != "" {
+-			fmt.Printf("Main hand: %s\n", weapon)
+-		}
+-
+-		if weapon, ok := character.Equipment.Weapon["off hand"]; ok && weapon != "" {
+-			fmt.Printf("Off hand: %s\n", weapon)
+-		}
+-		if character.Equipment.Armor != "" {
+-			fmt.Printf("Armor: %s\n", character.Equipment.Armor)
+-		}
+-
+-		if character.Equipment.Shield != "" {
+-			fmt.Printf("Shield: %s\n", character.Equipment.Shield)
+-		}
+-
+-		fmt.Printf("Armor class: %d\n", service.CalculateArmorClass(character))
+-		fmt.Printf("Initiative bonus: %d\n", service.CalculateInitiative(&character.Stats))
+-		fmt.Printf("Passive perception: %d\n", service.CalculatePassivePerception(character))
++		fmt.Print(service.FormatCharacterView(char))
+ 
+ 	case "list":
+ 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
+-		characters, err := repo.List()
++		facade := service.NewCharacterFacade(repo, nil)
++
++		chars, err := facade.ListCharacters()
+ 		if err != nil {
+-			fmt.Println("error listing characters:", err)
++			fmt.Println("error listing characters: ", err)
+ 			os.Exit(2)
+ 		}
+-		if len(characters) == 0 {
++
++		if len(chars) == 0 {
+ 			fmt.Println("no characters found")
+ 			return
+ 		}
+-		for _, c := range characters {
++
++		for _, c := range chars {
+ 			fmt.Printf("- %s (%s %s)\n", c.Name, c.Race, c.Class)
+ 		}
+ 
+@@ -247,10 +145,13 @@ func main() {
+ 		}
+ 
+ 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
+-		if err := repo.Delete(*name); err != nil {
+-			fmt.Println("error deleting character:", err)
++		facade := service.NewCharacterFacade(repo, nil)
++
++		if err := facade.DeleteCharacter(*name); err != nil {
++			fmt.Println("error deleting character: ", err)
+ 			os.Exit(2)
+ 		}
++
+ 		fmt.Printf("deleted %s\n", *name)
+ 
+ 	case "equip":
+@@ -268,47 +169,31 @@ func main() {
+ 		}
+ 
+ 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
+-		character, err := repo.Load(*name)
+-		if err != nil {
+-			fmt.Printf("character %q not found\n", *name)
+-			return
+-		}
++		classRepo := class.NewClassRepository(allWeps, simple, martial)
++		facade := service.NewCharacterFacade(repo, classRepo)
+ 
+-		if *weapon != "" && *slot != "" {
+-			if character.Equipment.Weapon == nil {
+-				character.Equipment.Weapon = make(map[string]string)
+-			}
+-
+-			if existing, ok := character.Equipment.Weapon[*slot]; ok && existing != "" {
++		err := facade.EquipItem(*name, *weapon, *slot, *armor, *shield)
++		if err != nil {
++			switch err {
++			case domain.ErrSlotOccupied:
+ 				fmt.Printf("%s already occupied\n", *slot)
+ 				return
+-			}
+ 
+-			character.Equipment.Weapon[*slot] = *weapon
+-			if err := repo.Save(character); err != nil {
+-				fmt.Printf("error saving character: %v\n", err)
++			default:
++				fmt.Println("error equipping:", err)
+ 				os.Exit(2)
+ 			}
++		}
++
++		if *weapon != "" && *slot != "" {
+ 			fmt.Printf("Equipped weapon %s to %s\n", *weapon, *slot)
+ 			return
+ 		}
+-
+ 		if *armor != "" {
+-			character.Equipment.Armor = *armor
+-			if err := repo.Save(character); err != nil {
+-				fmt.Println("error saving character:", *armor)
+-				os.Exit(2)
+-			}
+ 			fmt.Printf("Equipped armor %s\n", *armor)
+ 			return
+ 		}
+-
+ 		if *shield != "" {
+-			character.Equipment.Shield = *shield
+-			if err := repo.Save(character); err != nil {
+-				fmt.Println("error saving character:", err)
+-				os.Exit(2)
+-			}
+ 			fmt.Printf("Equipped shield %s\n", *shield)
+ 			return
+ 		}
+@@ -327,57 +212,15 @@ func main() {
+ 		}
+ 
+ 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
+-		character, err := repo.Load(*name)
+-		if err != nil {
+-			fmt.Printf("character %q not found\n", *name)
+-			return
+-		}
+-
+-		if character.Spellcasting == nil || !character.Spellcasting.CanCast {
+-			fmt.Printf("this class can't cast spells\n")
+-			return
+-		}
+-
+-		for _, s := range character.Spellcasting.LearnedSpells {
+-			if strings.EqualFold(s, *spell) {
+-				fmt.Printf("%s already learned\n", *spell)
+-				return
+-			}
+-		}
++		facade := service.NewCharacterFacade(repo, nil)
+ 
+-		if character.Spellcasting.PreparedMode {
+-			fmt.Printf("this class prepares spells and can't learn them\n")
+-			return
+-		}
+-
+-		// checks for non-existing spells (csv)
+-		level, err := service.GetSpellLevel(*spell)
++		message, err := facade.LearnSpell(*name, *spell)
+ 		if err != nil {
+ 			fmt.Println(err)
+ 			return
+ 		}
+ 
+-		if !service.IsSpellForClass(*spell, character.Class) {
+-			fmt.Printf("%s cannot learn %s\n", character.Class, *spell)
+-			return
+-		}
+-
+-		if level > 0 {
+-			if slots, ok := character.Spellcasting.Slots[level]; !ok || slots == 0 {
+-				fmt.Printf("the spell has higher level than the available spell slots\n")
+-				return
+-			}
+-		}
+-
+-		character.Spellcasting.LearnedMode = true
+-		character.Spellcasting.LearnedSpells = append(character.Spellcasting.LearnedSpells, *spell)
+-
+-		if err := repo.Save(character); err != nil {
+-			fmt.Println("error saving character:", err)
+-			os.Exit(2)
+-		}
+-
+-		fmt.Printf("Learned spell %s\n", *spell)
++		fmt.Println(message)
+ 
+ 	case "prepare-spell":
+ 		prepareCmd := flag.NewFlagSet("prepare-spell", flag.ExitOnError)
+@@ -391,57 +234,15 @@ func main() {
+ 		}
+ 
+ 		repo := repository.NewJsonRepository(filepath.Join("data", "characters.json"))
+-		character, err := repo.Load(*name)
+-		if err != nil {
+-			fmt.Printf("character %q not found\n", *name)
+-			return
+-		}
+-
+-		if character.Spellcasting == nil || !character.Spellcasting.CanCast {
+-			fmt.Printf("this class can't cast spells\n")
+-			return
+-		}
+-
+-		for _, s := range character.Spellcasting.PreparedSpells {
+-			if strings.EqualFold(s, *spell) {
+-				fmt.Printf("%s already prepared\n", *spell)
+-				return
+-			}
+-		}
+-
+-		if character.Spellcasting.LearnedMode {
+-			fmt.Printf("this class learns spells and can't prepare them\n")
+-			return
+-		}
++		facade := service.NewCharacterFacade(repo, nil)
+ 
+-		// checks for non-existing spells (csv)
+-		level, err := service.GetSpellLevel(*spell)
++		message, err := facade.PrepareSpell(*name, *spell)
+ 		if err != nil {
+ 			fmt.Println(err)
+ 			return
+ 		}
+ 
+-		if !service.IsSpellForClass(*spell, character.Class) {
+-			fmt.Printf("%s cannot prepare %s\n", character.Class, *spell)
+-			return
+-		}
+-
+-		if level > 0 {
+-			if slots, ok := character.Spellcasting.Slots[level]; !ok || slots == 0 {
+-				fmt.Printf("the spell has higher level than the available spell slots\n")
+-				return
+-			}
+-		}
+-
+-		character.Spellcasting.PreparedMode = true
+-		character.Spellcasting.PreparedSpells = append(character.Spellcasting.PreparedSpells, *spell)
+-
+-		if err := repo.Save(character); err != nil {
+-			fmt.Println("error saving character:", err)
+-			os.Exit(2)
+-		}
+-
+-		fmt.Printf("Prepared spell %s\n", *spell)
++		fmt.Println(message)
+ 
+ 	case "enrich-spells":
+ 		input := "5e-SRD-Spells.csv"
+diff --git a/repository/json_repository.go b/repository/json_repository.go
+index abc79f8..a6bc24c 100644
+--- a/repository/json_repository.go
++++ b/repository/json_repository.go
+@@ -7,7 +7,6 @@ import (
+ 	"path/filepath"
+ 
+ 	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+-	"github.com/DanielBartha/MPP-DnD-Character-Gen/service"
+ )
+ 
+ /*
+@@ -36,14 +35,14 @@ import (
+ â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â ›â£¿â£¿â €â €â €â €â €â €â €â €â¢â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €
+ â£¿â£¿â£¿â£¿â ¿â ›â ‰â ‰â â €â¢»â£¿â¡‡â €â €â €â €â €â €â¢€â ˆâ£¿â£¿â¡¿â ‰â ›â ›â ›â ‰â ‰â €
+ â£¿â¡¿â ‹â â €â €â¢€â£€â£ â¡´â£¸â£¿â£‡â¡„â €â €â €â €â¢€â¡¿â „â ™â ›â €â£€â£ â£¤â£¤â „â €â €
+-
+-Accurate representation of me coding this
+ */
+ 
+ type JsonRepository struct {
+ 	filePath string
+ }
+ 
++var _ domain.Repository = (*JsonRepository)(nil)
++
+ func NewJsonRepository(filePath string) *JsonRepository {
+ 	dir := filepath.Dir(filePath)
+ 	_ = os.MkdirAll(dir, 0755)
+@@ -51,8 +50,6 @@ func NewJsonRepository(filePath string) *JsonRepository {
+ }
+ 
+ func (repo *JsonRepository) Save(character *domain.Character) error {
+-	service.ComputeDerivedStats(character)
+-
+ 	characters, _ := repo.List()
+ 
+ 	updated := false
+@@ -82,7 +79,6 @@ func (repo *JsonRepository) Load(name string) (*domain.Character, error) {
+ 
+ 	for _, c := range characters {
+ 		if c.Name == name {
+-			service.ComputeDerivedStats(c)
+ 			return c, nil
+ 		}
+ 	}
+diff --git a/repository/repository.go b/repository/repository.go
+deleted file mode 100644
+index 02f453a..0000000
+--- a/repository/repository.go
++++ /dev/null
+@@ -1,10 +0,0 @@
+-package repository
+-
+-import "github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+-
+-type CharacterRepository interface {
+-	Save(character *domain.Character) error
+-	Load(name string) (*domain.Character, error)
+-	List() ([]*domain.Character, error)
+-	Delete(name string) error
+-}
+diff --git a/service/api_client.go b/service/api_client.go
+index bdbe85c..b781a48 100644
+--- a/service/api_client.go
++++ b/service/api_client.go
+@@ -135,7 +135,6 @@ func FetchArmor(index string) (*apiArmorResp, error) {
+ 	return &r, nil
+ }
+ 
+-// many many moons ago, many many spells were created which is why this batching is needed
+ func FetchSpellsBatch(indexes []string) map[string]*apiSpellResp {
+ 	results := make(map[string]*apiSpellResp)
+ 
+diff --git a/service/api_fetcher.go b/service/api_fetcher.go
+index faa92c1..9a77574 100644
+--- a/service/api_fetcher.go
++++ b/service/api_fetcher.go
+@@ -2,6 +2,13 @@ package service
+ 
+ import "github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+ 
++type apiArmorDomain struct {
++	Name     string
++	BaseAC   int
++	DexBonus bool
++	MaxBonus int
++}
++
+ func ToDomainSpell(r *apiSpellResp) *domain.SpellInfo {
+ 	return &domain.SpellInfo{
+ 		Name:   r.Name,
+@@ -19,8 +26,8 @@ func ToDomainWeapon(r *apiWeaponResp) *domain.WeaponInfo {
+ 	}
+ }
+ 
+-func ToDomainArmor(r *apiArmorResp) *domain.ArmorInfo {
+-	return &domain.ArmorInfo{
++func ToDomainArmor(r *apiArmorResp) *apiArmorDomain {
++	return &apiArmorDomain{
+ 		Name:     r.Name,
+ 		BaseAC:   r.ArmorClass.Base,
+ 		DexBonus: r.ArmorClass.DexBonus,
+diff --git a/service/character_facade.go b/service/character_facade.go
+new file mode 100644
+index 0000000..4084582
+--- /dev/null
++++ b/service/character_facade.go
+@@ -0,0 +1,120 @@
++package service
++
++import (
++	"fmt"
++
++	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
++	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain/class"
++)
++
++type CharacterFacade struct {
++	repo domain.Repository
++	svc  *CharacterService
++}
++
++func NewCharacterFacade(repo domain.Repository, classRepo *class.ClassRepository) *CharacterFacade {
++	return &CharacterFacade{
++		repo: repo,
++		svc:  NewCharacterService(classRepo),
++	}
++}
++
++func (f *CharacterFacade) CreateCharacter(c *domain.Character) error {
++	c.Skills = f.svc.GetClassSkills(c)
++	f.svc.InitSpellcasting(c)
++	ComputeDerivedStats(c)
++	return f.repo.Save(c)
++}
++
++func (f *CharacterFacade) ViewCharacter(name string) (*domain.Character, error) {
++	char, err := f.repo.Load(name)
++	if err != nil {
++		return nil, err
++	}
++
++	ComputeDerivedStats(char)
++	return char, nil
++}
++
++func (f *CharacterFacade) ListCharacters() ([]*domain.Character, error) {
++	chars, err := f.repo.List()
++	if err != nil {
++		return nil, err
++	}
++
++	return chars, nil
++}
++
++func (f *CharacterFacade) DeleteCharacter(name string) error {
++	return f.repo.Delete(name)
++}
++
++func (f *CharacterFacade) EquipItem(name, weapon, slot, armor, shield string) error {
++	character, err := f.repo.Load(name)
++	if err != nil {
++		return err
++	}
++
++	if weapon != "" && slot != "" {
++		if err := character.EquipWeapon(slot, weapon); err != nil {
++			return err
++		}
++	}
++
++	if armor != "" {
++		if err := character.EquipArmor(armor); err != nil {
++			return err
++		}
++	}
++
++	if shield != "" {
++		if err := character.EquipShield(shield); err != nil {
++			return err
++		}
++	}
++
++	return f.repo.Save(character)
++}
++
++func (f *CharacterFacade) LearnSpell(name, spell string) (string, error) {
++	char, err := f.repo.Load(name)
++	if err != nil {
++		return "", fmt.Errorf("character %q not found", name)
++	}
++
++	spellService := NewSpellService()
++	message, err := spellService.LearnSpell(char, spell)
++	if err != nil {
++		return "", err
++	}
++
++	if err := f.repo.Save(char); err != nil {
++		return "", fmt.Errorf("error saving character: %v", err)
++	}
++
++	return message, nil
++}
++
++func (f *CharacterFacade) PrepareSpell(name, spell string) (string, error) {
++	char, err := f.repo.Load(name)
++	if err != nil {
++		return "", fmt.Errorf("character %q not found", name)
++	}
++
++	spellService := NewSpellService()
++	message, err := spellService.PrepareSpell(char, spell)
++	if err != nil {
++		return "", err
++	}
++
++	if err := f.repo.Save(char); err != nil {
++		return "", fmt.Errorf("error saving character: %v", err)
++	}
++
++	return message, nil
++}
++
++// hook up for racial bonuses assignment for later
++// if fn := f.svc.ApplyRacialBonusesSkillProficiencies; fn != nil {
++// 	fn(c)
++// }
+diff --git a/service/character_formatter.go b/service/character_formatter.go
+new file mode 100644
+index 0000000..ea11637
+--- /dev/null
++++ b/service/character_formatter.go
+@@ -0,0 +1,88 @@
++package service
++
++import (
++	"fmt"
++	"strings"
++
++	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
++)
++
++func FormatCharacterView(c *domain.Character) string {
++	var sb strings.Builder
++
++	fmt.Fprintf(&sb,
++		"Name: %s\n"+
++			"Class: %s\n"+
++			"Race: %s\n"+
++			"Background: %s\n"+
++			"Level: %d\n"+
++			"Ability scores:\n"+
++			"  STR: %d (%+d)\n"+
++			"  DEX: %d (%+d)\n"+
++			"  CON: %d (%+d)\n"+
++			"  INT: %d (%+d)\n"+
++			"  WIS: %d (%+d)\n"+
++			"  CHA: %d (%+d)\n"+
++			"Proficiency bonus: +%d\n"+
++			"Skill proficiencies: %s\n",
++		c.Name,
++		strings.ToLower(c.Class),
++		strings.ToLower(c.Race),
++		c.Background,
++		c.Level,
++		c.Stats.Str, c.Stats.StrMod,
++		c.Stats.Dex, c.Stats.DexMod,
++		c.Stats.Con, c.Stats.ConMod,
++		c.Stats.Intel, c.Stats.IntelMod,
++		c.Stats.Wis, c.Stats.WisMod,
++		c.Stats.Cha, c.Stats.ChaMod,
++		c.Proficiency,
++		strings.Join(c.Skills.Skills, ", "),
++	)
++
++	if c.Spellcasting != nil && c.Spellcasting.CanCast {
++		fmt.Fprintln(&sb, "Spell slots:")
++
++		if c.Spellcasting.CantripsKnown > 0 {
++			fmt.Fprintf(&sb, "  Level 0: %d\n", c.Spellcasting.CantripsKnown)
++		}
++
++		for lvl := 1; lvl <= 9; lvl++ {
++			if count, ok := c.Spellcasting.MaxSlots[lvl]; ok && count > 0 {
++				fmt.Fprintf(&sb, "  Level %d: %d\n", lvl, count)
++			}
++		}
++
++		if c.Spellcasting.Ability != "" {
++			fmt.Fprintf(&sb, "Spellcasting ability: %s\n", strings.ToLower(c.Spellcasting.Ability))
++			fmt.Fprintf(&sb, "Spell save DC: %d\n", c.Spellcasting.SpellSaveDC)
++			fmt.Fprintf(&sb, "Spell attack bonus: +%d\n", c.Spellcasting.SpellAttackBonus)
++		}
++	}
++
++	if weapon, ok := c.Equipment.Weapon["main hand"]; ok && weapon != "" {
++		fmt.Fprintf(&sb, "Main hand: %s\n", weapon)
++	}
++
++	if weapon, ok := c.Equipment.Weapon["off hand"]; ok && weapon != "" {
++		fmt.Fprintf(&sb, "Off hand: %s\n", weapon)
++	}
++	if c.Equipment.Armor != "" {
++		fmt.Fprintf(&sb, "Armor: %s\n", c.Equipment.Armor)
++	}
++
++	if c.Equipment.Shield != "" {
++		fmt.Fprintf(&sb, "Shield: %s\n", c.Equipment.Shield)
++	}
++
++	fmt.Fprintf(&sb,
++		"Armor class: %d\n"+
++			"Initiative bonus: %d\n"+
++			"Passive perception: %d\n",
++		c.ArmorClass,
++		c.InitiativeBonus,
++		c.PassivePerception,
++	)
++
++	return sb.String()
++}
+diff --git a/service/character_service.go b/service/character_service.go
+index 406098c..472fa24 100644
+--- a/service/character_service.go
++++ b/service/character_service.go
+@@ -1,54 +1,22 @@
+ package service
+ 
+ import (
+-	"strings"
+-
+-	"github.com/DanielBartha/MPP-DnD-Character-Gen/characterClasses"
+ 	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
++	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain/class"
+ )
+ 
+ type CharacterService struct {
+-	// CharacterSkillProvider in the future for loading data from db
+-	// c'est possible
+-}
+-
+-func NewCharacterService() *CharacterService {
+-	return &CharacterService{}
++	classRepo *class.ClassRepository
+ }
+ 
+-func abilityModifier(score int) int {
+-	result := (score - 10) / 2
+-	if (score-10)%2 < 0 {
+-		result--
++func NewCharacterService(classRepo *class.ClassRepository) *CharacterService {
++	return &CharacterService{
++		classRepo: classRepo,
+ 	}
+-	return result
+-}
+-
+-func (s *CharacterService) UpdateProficiency(character *domain.Character) {
+-	switch {
+-	case character.Level >= 17:
+-		character.Proficiency = 6
+-	case character.Level >= 13:
+-		character.Proficiency = 5
+-	case character.Level >= 9:
+-		character.Proficiency = 4
+-	case character.Level >= 5:
+-		character.Proficiency = 3
+-	default:
+-		character.Proficiency = 2
+-	}
+-
+-	character.Stats.StrMod = abilityModifier(character.Stats.Str)
+-	character.Stats.DexMod = abilityModifier(character.Stats.Dex)
+-	character.Stats.ConMod = abilityModifier(character.Stats.Con)
+-	character.Stats.IntelMod = abilityModifier(character.Stats.Intel)
+-	character.Stats.WisMod = abilityModifier(character.Stats.Wis)
+-	character.Stats.ChaMod = abilityModifier(character.Stats.Cha)
+ }
+ 
+ func (s *CharacterService) GetClassSkills(c *domain.Character) domain.ClassLoadout {
+-	classKey := strings.ToLower(strings.TrimSpace(c.Class))
+-	cs, ok := characterClasses.Classes[classKey]
++	cs, ok := s.classRepo.Get(c.Class)
+ 
+ 	if !ok {
+ 		return domain.ClassLoadout{
+@@ -62,17 +30,14 @@ func (s *CharacterService) GetClassSkills(c *domain.Character) domain.ClassLoado
+ 		}
+ 	}
+ 
+-	src := cs.Skills
+-	localSkills := make([]string, len(src))
+-	copy(localSkills, src)
+-
++	src := append([]string{}, cs.Skills...)
+ 	selected := []string{}
+-	if cs.MaxAllowed > 0 && len(localSkills) > 0 {
++	if cs.MaxAllowed > 0 && len(src) > 0 {
+ 		limit := cs.MaxAllowed
+-		if limit > len(localSkills) {
+-			limit = len(localSkills)
++		if limit > len(src) {
++			limit = len(src)
+ 		}
+-		selected = localSkills[:limit]
++		selected = src[:limit]
+ 	}
+ 
+ 	selected = append(selected, "insight", "religion")
+@@ -87,61 +52,3 @@ func (s *CharacterService) GetClassSkills(c *domain.Character) domain.ClassLoado
+ 		OffHand:    cs.OffHand,
+ 	}
+ }
+-
+-func (s *CharacterService) ApplyRacialBonuses(character *domain.Character) {
+-	race := strings.ToLower(strings.ReplaceAll(character.Race, " ", "-"))
+-	switch race {
+-	case "dwarf":
+-		character.Stats.Con += 2
+-
+-	case "hill-dwarf":
+-		character.Stats.Con += 2
+-		character.Stats.Wis += 1
+-
+-	case "elf":
+-		character.Stats.Dex += 2
+-
+-	case "halfling", "stout-halfling":
+-		character.Stats.Dex += 2
+-
+-	case "lightfoot-halfling":
+-		character.Stats.Dex += 2
+-		character.Stats.Cha++
+-
+-	case "human":
+-		character.Stats.Str++
+-		character.Stats.Dex++
+-		character.Stats.Con++
+-		character.Stats.Intel++
+-		character.Stats.Wis++
+-		character.Stats.Cha++
+-
+-	case "dragonborn":
+-		character.Stats.Str += 2
+-		character.Stats.Cha++
+-
+-	case "gnome":
+-		character.Stats.Intel += 2
+-
+-	// TODO: half-eelves get to choose which stats to increase besides the rizz, for now dex and wis as defaults
+-	case "half-elf":
+-		character.Stats.Cha += 2
+-		character.Stats.Dex++
+-		character.Stats.Wis++
+-
+-	case "half-orc":
+-		character.Stats.Str += 2
+-		character.Stats.Con++
+-
+-	case "tiefling":
+-		character.Stats.Cha += 2
+-		character.Stats.Intel++
+-	}
+-
+-	character.Stats.StrMod = (character.Stats.Str - 10) / 2
+-	character.Stats.DexMod = (character.Stats.Dex - 10) / 2
+-	character.Stats.ConMod = (character.Stats.Con - 10) / 2
+-	character.Stats.IntelMod = (character.Stats.Intel - 10) / 2
+-	character.Stats.WisMod = (character.Stats.Wis - 10) / 2
+-	character.Stats.ChaMod = (character.Stats.Cha - 10) / 2
+-}
+diff --git a/service/derived_stats.go b/service/derived_stats.go
+index c214f73..94be2ec 100644
+--- a/service/derived_stats.go
++++ b/service/derived_stats.go
+@@ -5,7 +5,7 @@ import (
+ )
+ 
+ func ComputeDerivedStats(c *domain.Character) {
+-	c.ArmorClass = CalculateArmorClass(c)
+-	c.InitiativeBonus = CalculateInitiative(&c.Stats)
+-	c.PassivePerception = CalculatePassivePerception(c)
++	c.ArmorClass = c.CalculateArmorClass()
++	c.InitiativeBonus = c.CalculateInitiative()
++	c.PassivePerception = c.CalculatePassivePerception()
+ }
+diff --git a/service/equipment_service.go b/service/equipment_service.go
+new file mode 100644
+index 0000000..554539a
+--- /dev/null
++++ b/service/equipment_service.go
+@@ -0,0 +1,39 @@
++package service
++
++import (
++	"fmt"
++
++	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
++)
++
++type EquipmentService struct{}
++
++func NewEquipmentService() *EquipmentService {
++	return &EquipmentService{}
++}
++
++func (s *EquipmentService) Equip(character *domain.Character, weapon, slot, armor, shield string) (string, error) {
++	if character.Equipment.Weapon == nil {
++		character.Equipment.Weapon = make(map[string]string)
++	}
++
++	switch {
++	case weapon != "" && slot != "":
++		if existing, ok := character.Equipment.Weapon[slot]; ok && existing != "" {
++			return "", fmt.Errorf("%s already occupied", slot)
++		}
++		character.Equipment.Weapon[slot] = weapon
++		return fmt.Sprintf("Equipped weapon %s to %s", weapon, slot), nil
++
++	case armor != "":
++		character.Equipment.Armor = armor
++		return fmt.Sprintf("Equipped armor %s", armor), nil
++
++	case shield != "":
++		character.Equipment.Shield = shield
++		return fmt.Sprintf("Equipped shield %s", shield), nil
++
++	default:
++		return "", fmt.Errorf("no equipment provided")
++	}
++}
+diff --git a/service/passive_perception.go b/service/passive_perception.go
+deleted file mode 100644
+index b440cd3..0000000
+--- a/service/passive_perception.go
++++ /dev/null
+@@ -1,15 +0,0 @@
+-package service
+-
+-import "github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+-
+-func CalculatePassivePerception(c *domain.Character) int {
+-	base := 10 + c.Stats.WisMod
+-
+-	for _, skill := range c.Skills.Skills {
+-		if skill == "perception" {
+-			base += c.Proficiency
+-			break
+-		}
+-	}
+-	return base
+-}
+diff --git a/service/sanitize_keys.go b/service/sanitize_keys.go
+index 4e6ad74..be289b6 100644
+--- a/service/sanitize_keys.go
++++ b/service/sanitize_keys.go
+@@ -17,21 +17,3 @@ func SanitizeApiKey(name string) string {
+ 	key = strings.TrimSpace(key)
+ 	return key
+ }
+-
+-func SanitizeLocalKey(name string) string {
+-	key := strings.ToLower(name)
+-	key = strings.ReplaceAll(key, "'", "")
+-	key = strings.ReplaceAll(key, "â€™", "")
+-	key = strings.ReplaceAll(key, "(", "")
+-	key = strings.ReplaceAll(key, ")", "")
+-	key = strings.ReplaceAll(key, ",", "")
+-	key = strings.ReplaceAll(key, "/", "-")
+-	key = strings.ReplaceAll(key, ":", "")
+-	key = strings.ReplaceAll(key, ".", "")
+-	key = strings.ReplaceAll(key, " ", "-")
+-	key = strings.ReplaceAll(key, " ", "-")
+-	key = strings.TrimSuffix(key, "-armor")
+-	key = strings.TrimSuffix(key, " armor")
+-	key = strings.TrimSpace(key)
+-	return key
+-}
+diff --git a/service/spell_service.go b/service/spell_service.go
+new file mode 100644
+index 0000000..76f8eae
+--- /dev/null
++++ b/service/spell_service.go
+@@ -0,0 +1,86 @@
++package service
++
++import (
++	"fmt"
++	"strings"
++
++	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
++)
++
++type SpellService struct{}
++
++func NewSpellService() *SpellService {
++	return &SpellService{}
++}
++
++func (s *SpellService) LearnSpell(c *domain.Character, spellName string) (string, error) {
++	if c.Spellcasting == nil || !c.Spellcasting.CanCast {
++		return "", fmt.Errorf("this class can't cast spells")
++	}
++
++	for _, s := range c.Spellcasting.LearnedSpells {
++		if strings.EqualFold(s, spellName) {
++			return "", fmt.Errorf("%s already learned", spellName)
++		}
++	}
++
++	if c.Spellcasting.PreparedMode {
++		return "", fmt.Errorf("this class prepares spells and can't learn them")
++	}
++
++	level, err := GetSpellLevel(spellName)
++	if err != nil {
++		return "", err
++	}
++
++	if !IsSpellForClass(spellName, c.Class) {
++		return "", fmt.Errorf("%s cannot learn %s", c.Class, spellName)
++	}
++
++	if level > 0 {
++		if slots, ok := c.Spellcasting.Slots[level]; !ok || slots == 0 {
++			return "", fmt.Errorf("the spell has higher level than the available spell slots")
++		}
++	}
++
++	c.Spellcasting.LearnedMode = true
++	c.Spellcasting.LearnedSpells = append(c.Spellcasting.LearnedSpells, spellName)
++
++	return fmt.Sprintf("Learned spell %s", spellName), nil
++}
++
++func (s *SpellService) PrepareSpell(c *domain.Character, spellName string) (string, error) {
++	if c.Spellcasting == nil || !c.Spellcasting.CanCast {
++		return "", fmt.Errorf("this class can't cast spells")
++	}
++
++	for _, s := range c.Spellcasting.PreparedSpells {
++		if strings.EqualFold(s, spellName) {
++			return "", fmt.Errorf("%s already prepared", spellName)
++		}
++	}
++
++	if c.Spellcasting.LearnedMode {
++		return "", fmt.Errorf("this class learns spells and can't prepare them")
++	}
++
++	level, err := GetSpellLevel(spellName)
++	if err != nil {
++		return "", err
++	}
++
++	if !IsSpellForClass(spellName, c.Class) {
++		return "", fmt.Errorf("%s cannot prepare %s", c.Class, spellName)
++	}
++
++	if level > 0 {
++		if slots, ok := c.Spellcasting.Slots[level]; !ok || slots == 0 {
++			return "", fmt.Errorf("the spell has higher level than the available spell slots")
++		}
++	}
++
++	c.Spellcasting.PreparedMode = true
++	c.Spellcasting.PreparedSpells = append(c.Spellcasting.PreparedSpells, spellName)
++
++	return fmt.Sprintf("Prepared spell %s", spellName), nil
++}
+diff --git a/service/spellcasting.go b/service/spellcasting.go
+index cc12acc..bd11db2 100644
+--- a/service/spellcasting.go
++++ b/service/spellcasting.go
+@@ -79,8 +79,8 @@ var pactCasterSlots = map[int]map[int]int{
+ 
+ func GetSlotsForClassLevel(class string, level int) (map[int]int, string, error) {
+ 	classKey := strings.ToLower(strings.TrimSpace(class))
+-	casterType, ok := domain.SpellcastingType[classKey]
+-	if !ok {
++	casterType := domain.GetSpellcastingType(classKey)
++	if casterType == "" {
+ 		return nil, "", fmt.Errorf("class %s is not a spellcaster", class)
+ 	}
+ 
diff --git a/repository/json_repository.go b/repository/json_repository.go
index abc79f8..a6bc24c 100644
--- a/repository/json_repository.go
+++ b/repository/json_repository.go
@@ -7,7 +7,6 @@ import (
 	"path/filepath"
 
 	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
-	"github.com/DanielBartha/MPP-DnD-Character-Gen/service"
 )
 
 /*
@@ -36,14 +35,14 @@ import (
 â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â ›â£¿â£¿â €â €â €â €â €â €â €â €â¢â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €
 â£¿â£¿â£¿â£¿â ¿â ›â ‰â ‰â â €â¢»â£¿â¡‡â €â €â €â €â €â €â¢€â ˆâ£¿â£¿â¡¿â ‰â ›â ›â ›â ‰â ‰â €
 â£¿â¡¿â ‹â â €â €â¢€â£€â£ â¡´â£¸â£¿â£‡â¡„â €â €â €â €â¢€â¡¿â „â ™â ›â €â£€â£ â£¤â£¤â „â €â €
-
-Accurate representation of me coding this
 */
 
 type JsonRepository struct {
 	filePath string
 }
 
+var _ domain.Repository = (*JsonRepository)(nil)
+
 func NewJsonRepository(filePath string) *JsonRepository {
 	dir := filepath.Dir(filePath)
 	_ = os.MkdirAll(dir, 0755)
@@ -51,8 +50,6 @@ func NewJsonRepository(filePath string) *JsonRepository {
 }
 
 func (repo *JsonRepository) Save(character *domain.Character) error {
-	service.ComputeDerivedStats(character)
-
 	characters, _ := repo.List()
 
 	updated := false
@@ -82,7 +79,6 @@ func (repo *JsonRepository) Load(name string) (*domain.Character, error) {
 
 	for _, c := range characters {
 		if c.Name == name {
-			service.ComputeDerivedStats(c)
 			return c, nil
 		}
 	}
diff --git a/repository/json_repository_test.go b/repository/json_repository_test.go
new file mode 100644
index 0000000..9e9409d
--- /dev/null
+++ b/repository/json_repository_test.go
@@ -0,0 +1,86 @@
+package repository_test
+
+import (
+	"path/filepath"
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/repository"
+)
+
+func tempRepo(t *testing.T) *repository.JsonRepository {
+	t.Helper()
+	tmpDir := t.TempDir()
+	file := filepath.Join(tmpDir, "characters.json")
+	return repository.NewJsonRepository(file)
+}
+
+func TestJsonRepository_SaveAndLoad(t *testing.T) {
+	repo := tempRepo(t)
+
+	char := &domain.Character{Name: "TestHero", Race: "elf", Class: "wizard", Level: 3}
+	err := repo.Save(char)
+	if err != nil {
+		t.Fatalf("Save failed: %v", err)
+	}
+
+	loaded, err := repo.Load("TestHero")
+	if err != nil {
+		t.Fatalf("Load failed: %v", err)
+	}
+
+	if loaded.Name != "TestHero" {
+		t.Errorf("expected name %q, got %q", "TestHero", loaded.Name)
+	}
+	if loaded.Class != "wizard" {
+		t.Errorf("expected class %q, got %q", "wizard", loaded.Class)
+	}
+	if loaded.Level != 3 {
+		t.Errorf("expected level 3, got %d", loaded.Level)
+	}
+}
+
+func TestJsonRepository_List(t *testing.T) {
+	repo := tempRepo(t)
+
+	repo.Save(&domain.Character{Name: "A"})
+	repo.Save(&domain.Character{Name: "B"})
+
+	list, err := repo.List()
+	if err != nil {
+		t.Fatalf("List error: %v", err)
+	}
+	if len(list) != 2 {
+		t.Errorf("expected 2 characters, got %d", len(list))
+	}
+}
+
+func TestJsonRepository_Delete(t *testing.T) {
+	repo := tempRepo(t)
+
+	repo.Save(&domain.Character{Name: "DeleteMe"})
+	repo.Save(&domain.Character{Name: "KeepMe"})
+
+	err := repo.Delete("DeleteMe")
+	if err != nil {
+		t.Fatalf("Delete failed: %v", err)
+	}
+
+	list, _ := repo.List()
+	if len(list) != 1 {
+		t.Fatalf("expected 1 character after delete, got %d", len(list))
+	}
+
+	if list[0].Name != "KeepMe" {
+		t.Errorf("expected remaining character to be KeepMe, got %s", list[0].Name)
+	}
+}
+
+func TestJsonRepository_Load_NotFound(t *testing.T) {
+	repo := tempRepo(t)
+
+	_, err := repo.Load("missing")
+	if err == nil {
+		t.Fatalf("expected error when loading missing character")
+	}
+}
diff --git a/repository/repository.go b/repository/repository.go
deleted file mode 100644
index 02f453a..0000000
--- a/repository/repository.go
+++ /dev/null
@@ -1,10 +0,0 @@
-package repository
-
-import "github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
-
-type CharacterRepository interface {
-	Save(character *domain.Character) error
-	Load(name string) (*domain.Character, error)
-	List() ([]*domain.Character, error)
-	Delete(name string) error
-}
diff --git a/service/api_client.go b/service/api_client.go
index bdbe85c..862978f 100644
--- a/service/api_client.go
+++ b/service/api_client.go
@@ -43,6 +43,10 @@ type apiArmorResp struct {
 	} `json:"armor_class"`
 }
 
+var fetchSpellFunc = FetchSpell
+var fetchWeaponFunc = FetchWeapon
+var fetchArmorFunc = FetchArmor
+
 var requestsPerSecond = 6
 
 var requestTimeout = 8 * time.Second
@@ -135,7 +139,8 @@ func FetchArmor(index string) (*apiArmorResp, error) {
 	return &r, nil
 }
 
-// many many moons ago, many many spells were created which is why this batching is needed
+var fetchSpellsBatchFn = FetchSpellsBatch
+
 func FetchSpellsBatch(indexes []string) map[string]*apiSpellResp {
 	results := make(map[string]*apiSpellResp)
 
@@ -149,7 +154,7 @@ func FetchSpellsBatch(indexes []string) map[string]*apiSpellResp {
 
 	worker := func() {
 		for idx := range chIn {
-			r, err := FetchSpell(idx)
+			r, err := fetchSpellFunc(idx)
 			chOut <- result{idx: idx, res: r, err: err}
 		}
 	}
@@ -207,6 +212,8 @@ func FetchSpellsBatch(indexes []string) map[string]*apiSpellResp {
 	return results
 }
 
+var fetchWeaponsBatchFn = FetchWeaponsBatch
+
 func FetchWeaponsBatch(indexes []string) map[string]*apiWeaponResp {
 	results := make(map[string]*apiWeaponResp)
 
@@ -221,7 +228,7 @@ func FetchWeaponsBatch(indexes []string) map[string]*apiWeaponResp {
 
 	worker := func() {
 		for idx := range chIn {
-			r, err := FetchWeapon(idx)
+			r, err := fetchWeaponFunc(idx)
 			chOut <- result{idx: idx, res: r, err: err}
 		}
 	}
@@ -277,6 +284,8 @@ func FetchWeaponsBatch(indexes []string) map[string]*apiWeaponResp {
 	return results
 }
 
+var fetchArmorBatchFn = FetchArmorBatch
+
 func FetchArmorBatch(indexes []string) map[string]*apiArmorResp {
 	results := make(map[string]*apiArmorResp)
 
@@ -291,7 +300,7 @@ func FetchArmorBatch(indexes []string) map[string]*apiArmorResp {
 
 	worker := func() {
 		for idx := range chIn {
-			r, err := FetchArmor(idx)
+			r, err := fetchArmorFunc(idx)
 			chOut <- result{idx: idx, res: r, err: err}
 		}
 	}
diff --git a/service/api_client_test.go b/service/api_client_test.go
new file mode 100644
index 0000000..67c3f6b
--- /dev/null
+++ b/service/api_client_test.go
@@ -0,0 +1,76 @@
+package service
+
+import (
+	"os"
+	"path/filepath"
+	"testing"
+)
+
+func fakeSpell(_ string) (*apiSpellResp, error) {
+	return &apiSpellResp{Name: "Fire Bolt", Level: 0}, nil
+}
+func fakeWeapon(_ string) (*apiWeaponResp, error) {
+	return &apiWeaponResp{Name: "Longsword"}, nil
+}
+func fakeArmor(_ string) (*apiArmorResp, error) {
+	return &apiArmorResp{Name: "Chain Mail", ArmorClass: struct {
+		Base     int  `json:"base"`
+		DexBonus bool `json:"dex_bonus"`
+		MaxBonus int  `json:"max_bonus"`
+	}{Base: 16}}, nil
+}
+
+func TestFetchSpellsBatch(t *testing.T) {
+	fetchSpellFunc = fakeSpell
+	defer func() { fetchSpellFunc = FetchSpell }()
+
+	idx := []string{"spell1", "spell2"}
+
+	results := FetchSpellsBatch(idx)
+
+	if len(results) != 2 {
+		t.Fatalf("expected 2 spells, got %d", len(results))
+	}
+
+	if results["spell1"].Name != "Fire Bolt" {
+		t.Errorf("unexpected spell result: %v", results["spell1"])
+	}
+
+	if _, err := os.Stat(filepath.Join("data", "api_cache", "spells.json")); err != nil {
+		t.Errorf("cache file not written")
+	}
+}
+
+func TestFetchWeaponsBatch(t *testing.T) {
+	fetchWeaponFunc = fakeWeapon
+	defer func() { fetchWeaponFunc = FetchWeapon }()
+
+	idx := []string{"w1"}
+
+	results := FetchWeaponsBatch(idx)
+
+	if results["w1"].Name != "Longsword" {
+		t.Errorf("unexpected weapon result: %v", results["w1"])
+	}
+}
+
+func TestFetchArmorBatch(t *testing.T) {
+	fetchArmorFunc = fakeArmor
+	defer func() { fetchArmorFunc = FetchArmor }()
+
+	idx := []string{"a1"}
+
+	results := FetchArmorBatch(idx)
+
+	if results["a1"].Name != "Chain Mail" {
+		t.Errorf("unexpected armor result: %v", results["a1"])
+	}
+}
+
+func TestMain(m *testing.M) {
+	os.RemoveAll("data/api_cache")
+	os.MkdirAll("data/api_cache", 0755)
+	code := m.Run()
+	os.RemoveAll("data/api_cache")
+	os.Exit(code)
+}
diff --git a/service/api_fetcher.go b/service/api_fetcher.go
index faa92c1..9a77574 100644
--- a/service/api_fetcher.go
+++ b/service/api_fetcher.go
@@ -2,6 +2,13 @@ package service
 
 import "github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
 
+type apiArmorDomain struct {
+	Name     string
+	BaseAC   int
+	DexBonus bool
+	MaxBonus int
+}
+
 func ToDomainSpell(r *apiSpellResp) *domain.SpellInfo {
 	return &domain.SpellInfo{
 		Name:   r.Name,
@@ -19,8 +26,8 @@ func ToDomainWeapon(r *apiWeaponResp) *domain.WeaponInfo {
 	}
 }
 
-func ToDomainArmor(r *apiArmorResp) *domain.ArmorInfo {
-	return &domain.ArmorInfo{
+func ToDomainArmor(r *apiArmorResp) *apiArmorDomain {
+	return &apiArmorDomain{
 		Name:     r.Name,
 		BaseAC:   r.ArmorClass.Base,
 		DexBonus: r.ArmorClass.DexBonus,
diff --git a/service/api_fetcher_test.go b/service/api_fetcher_test.go
new file mode 100644
index 0000000..a366acd
--- /dev/null
+++ b/service/api_fetcher_test.go
@@ -0,0 +1,81 @@
+package service
+
+import (
+	"testing"
+)
+
+func TestToDomainSpell(t *testing.T) {
+	input := &apiSpellResp{
+		Name:  "Fire Bolt",
+		Level: 0,
+		School: struct {
+			Name string `json:"name"`
+		}{Name: "Evocation"},
+		Range: "120 feet",
+	}
+
+	got := ToDomainSpell(input)
+
+	if got.Name != "Fire Bolt" {
+		t.Errorf("expected spell name Fire Bolt, got %s", got.Name)
+	}
+	if got.School != "Evocation" {
+		t.Errorf("expected school Evocation, got %s", got.School)
+	}
+	if got.Range != "120 feet" {
+		t.Errorf("expected range 120 feet, got %s", got.Range)
+	}
+}
+
+func TestToDomainWeapon(t *testing.T) {
+	input := &apiWeaponResp{
+		Name:           "Longsword",
+		WeaponCategory: "Martial",
+		Range: struct {
+			Normal int `json:"normal"`
+			Long   int `json:"long"`
+		}{Normal: 5, Long: 0},
+		TwoHanded: false,
+	}
+
+	got := ToDomainWeapon(input)
+
+	if got.Name != "Longsword" {
+		t.Errorf("expected name Longsword, got %s", got.Name)
+	}
+	if got.Category != "Martial" {
+		t.Errorf("expected category Martial, got %s", got.Category)
+	}
+	if got.Range != 5 {
+		t.Errorf("expected range 5, got %d", got.Range)
+	}
+	if got.TwoHanded != false {
+		t.Errorf("expected TwoHanded false, got %v", got.TwoHanded)
+	}
+}
+
+func TestToDomainArmor(t *testing.T) {
+	input := &apiArmorResp{
+		Name: "Chain Mail",
+		ArmorClass: struct {
+			Base     int  `json:"base"`
+			DexBonus bool `json:"dex_bonus"`
+			MaxBonus int  `json:"max_bonus"`
+		}{Base: 16, DexBonus: false, MaxBonus: 0},
+	}
+
+	got := ToDomainArmor(input)
+
+	if got.Name != "Chain Mail" {
+		t.Errorf("expected Chain Mail, got %s", got.Name)
+	}
+	if got.BaseAC != 16 {
+		t.Errorf("expected BaseAC 16, got %d", got.BaseAC)
+	}
+	if got.DexBonus != false {
+		t.Errorf("expected DexBonus false, got %v", got.DexBonus)
+	}
+	if got.MaxBonus != 0 {
+		t.Errorf("expected MaxBonus 0, got %d", got.MaxBonus)
+	}
+}
diff --git a/service/character_facade.go b/service/character_facade.go
new file mode 100644
index 0000000..e1e7b11
--- /dev/null
+++ b/service/character_facade.go
@@ -0,0 +1,119 @@
+package service
+
+import (
+	"fmt"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain/class"
+)
+
+type CharacterFacade struct {
+	repo domain.Repository
+	svc  *CharacterService
+}
+
+func NewCharacterFacade(repo domain.Repository, classRepo *class.ClassRepository) *CharacterFacade {
+	return &CharacterFacade{
+		repo: repo,
+		svc:  NewCharacterService(classRepo),
+	}
+}
+
+func (f *CharacterFacade) CreateCharacter(c *domain.Character) error {
+	c.Skills = f.svc.GetClassSkills(c)
+	c.ApplyRacialBonuses()
+	c.UpdateProficiency()
+	c.ApplyRacialSkillProficiencies()
+	f.svc.InitSpellcasting(c)
+	ComputeDerivedStats(c)
+
+	return f.repo.Save(c)
+}
+
+func (f *CharacterFacade) ViewCharacter(name string) (*domain.Character, error) {
+	char, err := f.repo.Load(name)
+	if err != nil {
+		return nil, err
+	}
+
+	ComputeDerivedStats(char)
+	return char, nil
+}
+
+func (f *CharacterFacade) ListCharacters() ([]*domain.Character, error) {
+	chars, err := f.repo.List()
+	if err != nil {
+		return nil, err
+	}
+
+	return chars, nil
+}
+
+func (f *CharacterFacade) DeleteCharacter(name string) error {
+	return f.repo.Delete(name)
+}
+
+func (f *CharacterFacade) EquipItem(name, weapon, slot, armor, shield string) error {
+	character, err := f.repo.Load(name)
+	if err != nil {
+		return err
+	}
+
+	if weapon != "" && slot != "" {
+		if err := character.EquipWeapon(slot, weapon); err != nil {
+			return err
+		}
+	}
+
+	if armor != "" {
+		if err := character.EquipArmor(armor); err != nil {
+			return err
+		}
+	}
+
+	if shield != "" {
+		if err := character.EquipShield(shield); err != nil {
+			return err
+		}
+	}
+
+	return f.repo.Save(character)
+}
+
+func (f *CharacterFacade) LearnSpell(name, spell string) (string, error) {
+	char, err := f.repo.Load(name)
+	if err != nil {
+		return "", fmt.Errorf("character %q not found", name)
+	}
+
+	spellService := NewSpellService()
+	message, err := spellService.LearnSpell(char, spell)
+	if err != nil {
+		return "", err
+	}
+
+	if err := f.repo.Save(char); err != nil {
+		return "", fmt.Errorf("error saving character: %v", err)
+	}
+
+	return message, nil
+}
+
+func (f *CharacterFacade) PrepareSpell(name, spell string) (string, error) {
+	char, err := f.repo.Load(name)
+	if err != nil {
+		return "", fmt.Errorf("character %q not found", name)
+	}
+
+	spellService := NewSpellService()
+	message, err := spellService.PrepareSpell(char, spell)
+	if err != nil {
+		return "", err
+	}
+
+	if err := f.repo.Save(char); err != nil {
+		return "", fmt.Errorf("error saving character: %v", err)
+	}
+
+	return message, nil
+}
diff --git a/service/character_facade_test.go b/service/character_facade_test.go
new file mode 100644
index 0000000..1d0b35a
--- /dev/null
+++ b/service/character_facade_test.go
@@ -0,0 +1,117 @@
+package service
+
+import (
+	"errors"
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain/class"
+)
+
+type fakeRepo struct {
+	storage map[string]*domain.Character
+	saveErr error
+}
+
+func newFakeRepo() *fakeRepo {
+	return &fakeRepo{storage: make(map[string]*domain.Character)}
+}
+
+func (r *fakeRepo) Save(c *domain.Character) error {
+	if r.saveErr != nil {
+		return r.saveErr
+	}
+	r.storage[c.Name] = c
+	return nil
+}
+func (r *fakeRepo) Load(name string) (*domain.Character, error) {
+	if c, ok := r.storage[name]; ok {
+		return c, nil
+	}
+	return nil, errors.New("not found")
+}
+func (r *fakeRepo) List() ([]*domain.Character, error) {
+	result := []*domain.Character{}
+	for _, c := range r.storage {
+		result = append(result, c)
+	}
+	return result, nil
+}
+func (r *fakeRepo) Delete(name string) error {
+	delete(r.storage, name)
+	return nil
+}
+
+func Get(string) (class.ClassSkills, bool) {
+	return class.ClassSkills{
+		MaxAllowed: 2,
+		Skills:     []string{"athletics", "perception"},
+		Armor:      []string{},
+	}, true
+}
+
+func TestFacade_CreateCharacter(t *testing.T) {
+	repo := newFakeRepo()
+	facade := NewCharacterFacade(repo, &class.ClassRepository{})
+
+	char := &domain.Character{
+		Name:  "Test",
+		Race:  "dwarf",
+		Class: "fighter",
+		Level: 1,
+	}
+
+	err := facade.CreateCharacter(char)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	saved, _ := repo.Load("Test")
+	if saved == nil {
+		t.Fatalf("character not saved")
+	}
+
+	if saved.Proficiency == 0 {
+		t.Error("expected proficiency to be initialized")
+	}
+	if saved.ArmorClass == 0 {
+		t.Error("expected derived stats to be calculated")
+	}
+}
+
+func TestFacade_ViewCharacter_RecomputesDerivedStats(t *testing.T) {
+	repo := newFakeRepo()
+	facade := NewCharacterFacade(repo, &class.ClassRepository{})
+
+	char := &domain.Character{
+		Name:  "Test",
+		Class: "fighter",
+		Level: 1,
+	}
+	repo.Save(char)
+
+	out, err := facade.ViewCharacter("Test")
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	if out.ArmorClass == 0 {
+		t.Error("expected derived stats to be recalculated on view")
+	}
+}
+
+func TestFacade_DeleteCharacter(t *testing.T) {
+	repo := newFakeRepo()
+	facade := NewCharacterFacade(repo, &class.ClassRepository{})
+
+	repo.Save(&domain.Character{Name: "Test"})
+
+	err := facade.DeleteCharacter("Test")
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	if _, err := repo.Load("Test"); err == nil {
+		t.Error("expected character to be deleted")
+	}
+}
diff --git a/service/character_formatter.go b/service/character_formatter.go
new file mode 100644
index 0000000..ea11637
--- /dev/null
+++ b/service/character_formatter.go
@@ -0,0 +1,88 @@
+package service
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func FormatCharacterView(c *domain.Character) string {
+	var sb strings.Builder
+
+	fmt.Fprintf(&sb,
+		"Name: %s\n"+
+			"Class: %s\n"+
+			"Race: %s\n"+
+			"Background: %s\n"+
+			"Level: %d\n"+
+			"Ability scores:\n"+
+			"  STR: %d (%+d)\n"+
+			"  DEX: %d (%+d)\n"+
+			"  CON: %d (%+d)\n"+
+			"  INT: %d (%+d)\n"+
+			"  WIS: %d (%+d)\n"+
+			"  CHA: %d (%+d)\n"+
+			"Proficiency bonus: +%d\n"+
+			"Skill proficiencies: %s\n",
+		c.Name,
+		strings.ToLower(c.Class),
+		strings.ToLower(c.Race),
+		c.Background,
+		c.Level,
+		c.Stats.Str, c.Stats.StrMod,
+		c.Stats.Dex, c.Stats.DexMod,
+		c.Stats.Con, c.Stats.ConMod,
+		c.Stats.Intel, c.Stats.IntelMod,
+		c.Stats.Wis, c.Stats.WisMod,
+		c.Stats.Cha, c.Stats.ChaMod,
+		c.Proficiency,
+		strings.Join(c.Skills.Skills, ", "),
+	)
+
+	if c.Spellcasting != nil && c.Spellcasting.CanCast {
+		fmt.Fprintln(&sb, "Spell slots:")
+
+		if c.Spellcasting.CantripsKnown > 0 {
+			fmt.Fprintf(&sb, "  Level 0: %d\n", c.Spellcasting.CantripsKnown)
+		}
+
+		for lvl := 1; lvl <= 9; lvl++ {
+			if count, ok := c.Spellcasting.MaxSlots[lvl]; ok && count > 0 {
+				fmt.Fprintf(&sb, "  Level %d: %d\n", lvl, count)
+			}
+		}
+
+		if c.Spellcasting.Ability != "" {
+			fmt.Fprintf(&sb, "Spellcasting ability: %s\n", strings.ToLower(c.Spellcasting.Ability))
+			fmt.Fprintf(&sb, "Spell save DC: %d\n", c.Spellcasting.SpellSaveDC)
+			fmt.Fprintf(&sb, "Spell attack bonus: +%d\n", c.Spellcasting.SpellAttackBonus)
+		}
+	}
+
+	if weapon, ok := c.Equipment.Weapon["main hand"]; ok && weapon != "" {
+		fmt.Fprintf(&sb, "Main hand: %s\n", weapon)
+	}
+
+	if weapon, ok := c.Equipment.Weapon["off hand"]; ok && weapon != "" {
+		fmt.Fprintf(&sb, "Off hand: %s\n", weapon)
+	}
+	if c.Equipment.Armor != "" {
+		fmt.Fprintf(&sb, "Armor: %s\n", c.Equipment.Armor)
+	}
+
+	if c.Equipment.Shield != "" {
+		fmt.Fprintf(&sb, "Shield: %s\n", c.Equipment.Shield)
+	}
+
+	fmt.Fprintf(&sb,
+		"Armor class: %d\n"+
+			"Initiative bonus: %d\n"+
+			"Passive perception: %d\n",
+		c.ArmorClass,
+		c.InitiativeBonus,
+		c.PassivePerception,
+	)
+
+	return sb.String()
+}
diff --git a/service/character_formatter_test.go b/service/character_formatter_test.go
new file mode 100644
index 0000000..1055afa
--- /dev/null
+++ b/service/character_formatter_test.go
@@ -0,0 +1,105 @@
+package service
+
+import (
+	"strings"
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestFormatCharacterView_BasicFields(t *testing.T) {
+
+	char := &domain.Character{
+		Name:       "TestHero",
+		Race:       "Elf",
+		Class:      "Wizard",
+		Background: "Sage",
+		Level:      3,
+		Stats: domain.Stats{
+			Str: 8, StrMod: -1,
+			Dex: 14, DexMod: 2,
+			Con: 12, ConMod: 1,
+			Intel: 16, IntelMod: 3,
+			Wis: 10, WisMod: 0,
+			Cha: 13, ChaMod: 1,
+		},
+		Proficiency: 2,
+		Skills: domain.ClassLoadout{
+			Skills: []string{"arcana", "history"},
+		},
+		ArmorClass:        12,
+		InitiativeBonus:   2,
+		PassivePerception: 10,
+	}
+
+	out := FormatCharacterView(char)
+
+	assertContains(t, out, "Name: TestHero")
+	assertContains(t, out, "Class: wizard")
+	assertContains(t, out, "Race: elf")
+	assertContains(t, out, "Background: Sage")
+	assertContains(t, out, "Level: 3")
+
+	assertContains(t, out, "STR: 8 (-1)")
+	assertContains(t, out, "DEX: 14 (+2)")
+	assertContains(t, out, "INT: 16 (+3)")
+
+	assertContains(t, out, "Skill proficiencies: arcana, history")
+	assertContains(t, out, "Armor class: 12")
+	assertContains(t, out, "Initiative bonus: 2")
+	assertContains(t, out, "Passive perception: 10")
+}
+
+func TestFormatCharacterView_SpellcastingSection(t *testing.T) {
+	char := &domain.Character{
+		Name:  "Mage",
+		Class: "Wizard",
+		Stats: domain.Stats{},
+		Spellcasting: &domain.Spellcasting{
+			CanCast:          true,
+			CantripsKnown:    3,
+			MaxSlots:         map[int]int{1: 2, 2: 0},
+			Ability:          "int",
+			SpellSaveDC:      14,
+			SpellAttackBonus: 6,
+		},
+	}
+
+	out := FormatCharacterView(char)
+
+	assertContains(t, out, "Spell slots:")
+	assertContains(t, out, "Level 0: 3")
+	assertContains(t, out, "Level 1: 2")
+	assertContains(t, out, "Spellcasting ability: int")
+	assertContains(t, out, "Spell save DC: 14")
+	assertContains(t, out, "Spell attack bonus: +6")
+}
+
+func TestFormatCharacterView_Equipment(t *testing.T) {
+	char := &domain.Character{
+		Name:  "Fighter",
+		Stats: domain.Stats{},
+		Equipment: domain.Equipment{
+			Weapon: map[string]string{
+				"main hand": "longsword",
+				"off hand":  "dagger",
+			},
+			Armor:  "chain mail",
+			Shield: "shield",
+		},
+	}
+
+	out := FormatCharacterView(char)
+
+	assertContains(t, out, "Main hand: longsword")
+	assertContains(t, out, "Off hand: dagger")
+	assertContains(t, out, "Armor: chain mail")
+	assertContains(t, out, "Shield: shield")
+}
+
+func assertContains(t *testing.T, out, sub string) {
+	t.Helper()
+	if !strings.Contains(out, sub) {
+		t.Errorf("expected output to contain %q\nOutput:\n%s", sub, out)
+	}
+}
diff --git a/service/character_service.go b/service/character_service.go
index 406098c..472fa24 100644
--- a/service/character_service.go
+++ b/service/character_service.go
@@ -1,54 +1,22 @@
 package service
 
 import (
-	"strings"
-
-	"github.com/DanielBartha/MPP-DnD-Character-Gen/characterClasses"
 	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain/class"
 )
 
 type CharacterService struct {
-	// CharacterSkillProvider in the future for loading data from db
-	// c'est possible
-}
-
-func NewCharacterService() *CharacterService {
-	return &CharacterService{}
+	classRepo *class.ClassRepository
 }
 
-func abilityModifier(score int) int {
-	result := (score - 10) / 2
-	if (score-10)%2 < 0 {
-		result--
+func NewCharacterService(classRepo *class.ClassRepository) *CharacterService {
+	return &CharacterService{
+		classRepo: classRepo,
 	}
-	return result
-}
-
-func (s *CharacterService) UpdateProficiency(character *domain.Character) {
-	switch {
-	case character.Level >= 17:
-		character.Proficiency = 6
-	case character.Level >= 13:
-		character.Proficiency = 5
-	case character.Level >= 9:
-		character.Proficiency = 4
-	case character.Level >= 5:
-		character.Proficiency = 3
-	default:
-		character.Proficiency = 2
-	}
-
-	character.Stats.StrMod = abilityModifier(character.Stats.Str)
-	character.Stats.DexMod = abilityModifier(character.Stats.Dex)
-	character.Stats.ConMod = abilityModifier(character.Stats.Con)
-	character.Stats.IntelMod = abilityModifier(character.Stats.Intel)
-	character.Stats.WisMod = abilityModifier(character.Stats.Wis)
-	character.Stats.ChaMod = abilityModifier(character.Stats.Cha)
 }
 
 func (s *CharacterService) GetClassSkills(c *domain.Character) domain.ClassLoadout {
-	classKey := strings.ToLower(strings.TrimSpace(c.Class))
-	cs, ok := characterClasses.Classes[classKey]
+	cs, ok := s.classRepo.Get(c.Class)
 
 	if !ok {
 		return domain.ClassLoadout{
@@ -62,17 +30,14 @@ func (s *CharacterService) GetClassSkills(c *domain.Character) domain.ClassLoado
 		}
 	}
 
-	src := cs.Skills
-	localSkills := make([]string, len(src))
-	copy(localSkills, src)
-
+	src := append([]string{}, cs.Skills...)
 	selected := []string{}
-	if cs.MaxAllowed > 0 && len(localSkills) > 0 {
+	if cs.MaxAllowed > 0 && len(src) > 0 {
 		limit := cs.MaxAllowed
-		if limit > len(localSkills) {
-			limit = len(localSkills)
+		if limit > len(src) {
+			limit = len(src)
 		}
-		selected = localSkills[:limit]
+		selected = src[:limit]
 	}
 
 	selected = append(selected, "insight", "religion")
@@ -87,61 +52,3 @@ func (s *CharacterService) GetClassSkills(c *domain.Character) domain.ClassLoado
 		OffHand:    cs.OffHand,
 	}
 }
-
-func (s *CharacterService) ApplyRacialBonuses(character *domain.Character) {
-	race := strings.ToLower(strings.ReplaceAll(character.Race, " ", "-"))
-	switch race {
-	case "dwarf":
-		character.Stats.Con += 2
-
-	case "hill-dwarf":
-		character.Stats.Con += 2
-		character.Stats.Wis += 1
-
-	case "elf":
-		character.Stats.Dex += 2
-
-	case "halfling", "stout-halfling":
-		character.Stats.Dex += 2
-
-	case "lightfoot-halfling":
-		character.Stats.Dex += 2
-		character.Stats.Cha++
-
-	case "human":
-		character.Stats.Str++
-		character.Stats.Dex++
-		character.Stats.Con++
-		character.Stats.Intel++
-		character.Stats.Wis++
-		character.Stats.Cha++
-
-	case "dragonborn":
-		character.Stats.Str += 2
-		character.Stats.Cha++
-
-	case "gnome":
-		character.Stats.Intel += 2
-
-	// TODO: half-eelves get to choose which stats to increase besides the rizz, for now dex and wis as defaults
-	case "half-elf":
-		character.Stats.Cha += 2
-		character.Stats.Dex++
-		character.Stats.Wis++
-
-	case "half-orc":
-		character.Stats.Str += 2
-		character.Stats.Con++
-
-	case "tiefling":
-		character.Stats.Cha += 2
-		character.Stats.Intel++
-	}
-
-	character.Stats.StrMod = (character.Stats.Str - 10) / 2
-	character.Stats.DexMod = (character.Stats.Dex - 10) / 2
-	character.Stats.ConMod = (character.Stats.Con - 10) / 2
-	character.Stats.IntelMod = (character.Stats.Intel - 10) / 2
-	character.Stats.WisMod = (character.Stats.Wis - 10) / 2
-	character.Stats.ChaMod = (character.Stats.Cha - 10) / 2
-}
diff --git a/service/character_service_test.go b/service/character_service_test.go
new file mode 100644
index 0000000..31600c1
--- /dev/null
+++ b/service/character_service_test.go
@@ -0,0 +1,76 @@
+package service
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain/class"
+)
+
+func fakeWeapons() ([]domain.WeaponInfo, []domain.WeaponInfo, []domain.WeaponInfo) {
+	all := []domain.WeaponInfo{{Name: "club"}, {Name: "dagger"}}
+	return all, all, all
+}
+
+func TestGetClassSkills_ValidClass(t *testing.T) {
+	all, simple, martial := fakeWeapons()
+	repo := class.NewClassRepository(all, simple, martial)
+	svc := NewCharacterService(repo)
+
+	char := &domain.Character{Class: "barbarian"}
+
+	loadout := svc.GetClassSkills(char)
+
+	if len(loadout.Skills) == 0 {
+		t.Fatalf("expected skills for barbarian, got none")
+	}
+
+	// barbarian MaxAllowed = 2 - first 2 skills, plus "insight","religion"
+	if got := loadout.Skills[0]; got != "animal handling" {
+		t.Errorf("expected first skill animal handling, got %s", got)
+	}
+	if got := loadout.Skills[1]; got != "athletics" {
+		t.Errorf("expected second skill athletics, got %s", got)
+	}
+
+	if !contains(loadout.Skills, "insight") {
+		t.Errorf("expected racial/class insight to be included")
+	}
+	if !contains(loadout.Skills, "religion") {
+		t.Errorf("expected racial/class religion to be included")
+	}
+}
+
+func TestGetClassSkills_UnknownClass(t *testing.T) {
+	all, simple, martial := fakeWeapons()
+	repo := class.NewClassRepository(all, simple, martial)
+	svc := NewCharacterService(repo)
+
+	char := &domain.Character{Class: "nonsense"}
+
+	loadout := svc.GetClassSkills(char)
+
+	if loadout.MaxAllowed != 0 {
+		t.Errorf("expected MaxAllowed 0, got %d", loadout.MaxAllowed)
+	}
+
+	expected := []string{"insight", "religion"}
+	if len(loadout.Skills) != len(expected) {
+		t.Fatalf("expected only default skills, got %v", loadout.Skills)
+	}
+
+	for _, skill := range expected {
+		if !contains(loadout.Skills, skill) {
+			t.Errorf("expected %s in skills, got %v", skill, loadout.Skills)
+		}
+	}
+}
+
+func contains(slice []string, val string) bool {
+	for _, s := range slice {
+		if s == val {
+			return true
+		}
+	}
+	return false
+}
diff --git a/service/derived_stats.go b/service/derived_stats.go
index c214f73..94be2ec 100644
--- a/service/derived_stats.go
+++ b/service/derived_stats.go
@@ -5,7 +5,7 @@ import (
 )
 
 func ComputeDerivedStats(c *domain.Character) {
-	c.ArmorClass = CalculateArmorClass(c)
-	c.InitiativeBonus = CalculateInitiative(&c.Stats)
-	c.PassivePerception = CalculatePassivePerception(c)
+	c.ArmorClass = c.CalculateArmorClass()
+	c.InitiativeBonus = c.CalculateInitiative()
+	c.PassivePerception = c.CalculatePassivePerception()
 }
diff --git a/service/derived_stats_test.go b/service/derived_stats_test.go
new file mode 100644
index 0000000..57c9566
--- /dev/null
+++ b/service/derived_stats_test.go
@@ -0,0 +1,32 @@
+package service
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestComputeDerivedStats(t *testing.T) {
+	char := &domain.Character{
+		Class: "fighter",
+		Stats: domain.Stats{Dex: 14, Wis: 12, Con: 10},
+	}
+	char.UpdateProficiency()
+
+	// no armor, no shield - AC = 10 + dex mod (2) = 12
+	ComputeDerivedStats(char)
+
+	if char.ArmorClass == 0 || char.InitiativeBonus == 0 || char.PassivePerception == 0 {
+		t.Fatalf("derived stats were not computed: %+v", char)
+	}
+
+	if char.ArmorClass != 12 {
+		t.Errorf("expected AC 12, got %d", char.ArmorClass)
+	}
+	if char.InitiativeBonus != 2 {
+		t.Errorf("expected InitiativeBonus 2, got %d", char.InitiativeBonus)
+	}
+	if char.PassivePerception != 11 { // 10 + wis mod 1
+		t.Errorf("expected PassivePerception 11, got %d", char.PassivePerception)
+	}
+}
diff --git a/service/enrich_armor.go b/service/enrich_armor.go
index aa5675b..3a542aa 100644
--- a/service/enrich_armor.go
+++ b/service/enrich_armor.go
@@ -57,7 +57,7 @@ func EnrichArmor(inputPath, outputPath string) error {
 		records = append(records, record)
 	}
 
-	results := FetchArmorBatch(armorIndexes)
+	results := fetchArmorBatchFn(armorIndexes)
 
 	var processed, missing int
 
diff --git a/service/enrich_armor_test.go b/service/enrich_armor_test.go
new file mode 100644
index 0000000..4115357
--- /dev/null
+++ b/service/enrich_armor_test.go
@@ -0,0 +1,67 @@
+package service
+
+import (
+	"encoding/csv"
+	"os"
+	"testing"
+)
+
+func TestEnrichArmor_BasicFlow(t *testing.T) {
+	input := "test_input.csv"
+	output := "test_output.csv"
+	defer os.Remove(input)
+	defer os.Remove(output)
+
+	// header + one armor row + one non-armor row
+	if err := os.WriteFile(input, []byte("Name,Type\nLeather,Armor\nRope,Gear\n"), 0o644); err != nil {
+		t.Fatalf("write input: %v", err)
+	}
+
+	orig := fetchArmorBatchFn
+	fetchArmorBatchFn = func(indexes []string) map[string]*apiArmorResp {
+
+		resp := &apiArmorResp{Name: "Leather"}
+		resp.ArmorClass.Base = 11
+		resp.ArmorClass.DexBonus = true
+		resp.ArmorClass.MaxBonus = 0
+
+		return map[string]*apiArmorResp{
+			"leather": resp,
+		}
+	}
+	defer func() { fetchArmorBatchFn = orig }()
+
+	if err := EnrichArmor(input, output); err != nil {
+		t.Fatalf("EnrichArmor error: %v", err)
+	}
+
+	f, err := os.Open(output)
+	if err != nil {
+		t.Fatalf("open output: %v", err)
+	}
+	defer f.Close()
+
+	r := csv.NewReader(f)
+	rows, err := r.ReadAll()
+	if err != nil {
+		t.Fatalf("read csv: %v", err)
+	}
+
+	if len(rows) != 3 {
+		t.Fatalf("expected 3 rows, got %d", len(rows))
+	}
+
+	if got := len(rows[0]); got < 5 {
+		t.Errorf("expected extended header, got %d columns", got)
+	}
+
+	// leather armor row: base_ac should be 11
+	// columns: Name,Type,base_ac,dex_bonus,max_bonus
+	if rows[1][2] != "11" {
+		t.Errorf("expected leather base_ac=11, got %s", rows[1][2])
+	}
+
+	if rows[2][2] != "N/A" || rows[2][3] != "N/A" || rows[2][4] != "N/A" {
+		t.Errorf("expected N/A in appended cols for non-armor row, got %v", rows[2])
+	}
+}
diff --git a/service/enrich_spells.go b/service/enrich_spells.go
index 7a57b8f..d326dc4 100644
--- a/service/enrich_spells.go
+++ b/service/enrich_spells.go
@@ -50,7 +50,7 @@ func EnrichSpells(inputPath, outputPath string) error {
 	}
 
 	fmt.Printf("Fetching data for %d spells...\n", len(indexes))
-	spellMap := FetchSpellsBatch(indexes)
+	spellMap := fetchSpellsBatchFn(indexes)
 
 	var processed, missing int
 
diff --git a/service/enrich_spells_test.go b/service/enrich_spells_test.go
new file mode 100644
index 0000000..54e6d56
--- /dev/null
+++ b/service/enrich_spells_test.go
@@ -0,0 +1,64 @@
+package service
+
+import (
+	"encoding/csv"
+	"os"
+	"testing"
+)
+
+func TestEnrichSpells_BasicFlow(t *testing.T) {
+	input := "test_spells_input.csv"
+	output := "test_spells_output.csv"
+	defer os.Remove(input)
+	defer os.Remove(output)
+
+	// header + 2 roes
+	content := "Name\nFire Bolt\nUnknown Spell\n"
+	if err := os.WriteFile(input, []byte(content), 0o644); err != nil {
+		t.Fatalf("write input: %v", err)
+	}
+
+	orig := fetchSpellsBatchFn
+
+	fetchSpellsBatchFn = func(indexes []string) map[string]*apiSpellResp {
+		resp := &apiSpellResp{
+			Name:  "Fire Bolt",
+			Range: "120 feet",
+		}
+		resp.School.Name = "Evocation"
+
+		return map[string]*apiSpellResp{
+			"fire-bolt": resp,
+		}
+	}
+
+	defer func() { fetchSpellsBatchFn = orig }()
+
+	if err := EnrichSpells(input, output); err != nil {
+		t.Fatalf("EnrichSpells error: %v", err)
+	}
+
+	f, err := os.Open(output)
+	if err != nil {
+		t.Fatalf("open output: %v", err)
+	}
+	defer f.Close()
+
+	r := csv.NewReader(f)
+	rows, err := r.ReadAll()
+	if err != nil {
+		t.Fatalf("read csv: %v", err)
+	}
+
+	if len(rows) != 3 {
+		t.Fatalf("expected 3 rows, got %d", len(rows))
+	}
+
+	if rows[1][1] != "Evocation" || rows[1][2] != "120 feet" {
+		t.Errorf("Fire Bolt enrichment failed: %v", rows[1])
+	}
+
+	if rows[2][1] != "N/A" || rows[2][2] != "N/A" {
+		t.Errorf("Unknown spell should have N/A values: %v", rows[2])
+	}
+}
diff --git a/service/enrich_weapons.go b/service/enrich_weapons.go
index 035cbe4..a7cfe4d 100644
--- a/service/enrich_weapons.go
+++ b/service/enrich_weapons.go
@@ -56,7 +56,7 @@ func EnrichWeapons(inputPath, outputPath string) error {
 	}
 
 	fmt.Printf("Fetching weapon data for %d weapons...\n", len(indexes))
-	weaponMap := FetchWeaponsBatch(indexes)
+	weaponMap := fetchWeaponsBatchFn(indexes)
 
 	if err := ensureDir(filepath.Dir(outputPath)); err != nil {
 		return err
diff --git a/service/enrich_weapons_test.go b/service/enrich_weapons_test.go
new file mode 100644
index 0000000..a196dd0
--- /dev/null
+++ b/service/enrich_weapons_test.go
@@ -0,0 +1,90 @@
+package service
+
+import (
+	"os"
+	"strings"
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestEnrichWeapons(t *testing.T) {
+	// fake csv
+	inputCSV := `name,type
+Longsword,Weapon
+Stick,Weapon
+Rock,Other`
+
+	in := createTempFile(t, inputCSV)
+	out := createTempFile(t, "")
+
+	// mock API response
+	original := fetchWeaponsBatchFn
+	fetchWeaponsBatchFn = func(indexes []string) map[string]*apiWeaponResp {
+		resp := &apiWeaponResp{
+			Name:           "Longsword",
+			WeaponCategory: "Martial",
+		}
+		resp.Range.Normal = 5
+		resp.TwoHanded = false
+
+		return map[string]*apiWeaponResp{
+			"longsword": resp,
+		}
+	}
+	defer func() { fetchWeaponsBatchFn = original }()
+
+	err := EnrichWeapons(in, out)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	got := readFile(t, out)
+	expectedContains := []string{
+		"Longsword,Martial,5,false",
+		"Stick,N/A,N/A,N/A",
+	}
+	for _, want := range expectedContains {
+		if !strings.Contains(got, want) {
+			t.Errorf("expected output to contain %q\nGot:\n%s", want, got)
+		}
+	}
+}
+
+func TestSimpleAndMartialWeapons(t *testing.T) {
+	weapons := []domain.WeaponInfo{
+		{Name: "Stick", Category: "Simple"},
+		{Name: "Longsword", Category: "Martial"},
+		{Name: "Bow", Category: "Simple"},
+	}
+
+	simple := SimpleWeapons(weapons)
+	if len(simple) != 2 {
+		t.Errorf("expected 2 simple weapons, got %d", len(simple))
+	}
+
+	martial := MartialWeapons(weapons)
+	if len(martial) != 1 {
+		t.Errorf("expected 1 martial weapon, got %d", len(martial))
+	}
+}
+
+func createTempFile(t *testing.T, content string) string {
+	t.Helper()
+	f, err := os.CreateTemp("", "wep_in")
+	if err != nil {
+		t.Fatal(err)
+	}
+	f.WriteString(content)
+	f.Close()
+	return f.Name()
+}
+
+func readFile(t *testing.T, path string) string {
+	t.Helper()
+	b, err := os.ReadFile(path)
+	if err != nil {
+		t.Fatal(err)
+	}
+	return string(b)
+}
diff --git a/service/equipment_service.go b/service/equipment_service.go
new file mode 100644
index 0000000..554539a
--- /dev/null
+++ b/service/equipment_service.go
@@ -0,0 +1,39 @@
+package service
+
+import (
+	"fmt"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+type EquipmentService struct{}
+
+func NewEquipmentService() *EquipmentService {
+	return &EquipmentService{}
+}
+
+func (s *EquipmentService) Equip(character *domain.Character, weapon, slot, armor, shield string) (string, error) {
+	if character.Equipment.Weapon == nil {
+		character.Equipment.Weapon = make(map[string]string)
+	}
+
+	switch {
+	case weapon != "" && slot != "":
+		if existing, ok := character.Equipment.Weapon[slot]; ok && existing != "" {
+			return "", fmt.Errorf("%s already occupied", slot)
+		}
+		character.Equipment.Weapon[slot] = weapon
+		return fmt.Sprintf("Equipped weapon %s to %s", weapon, slot), nil
+
+	case armor != "":
+		character.Equipment.Armor = armor
+		return fmt.Sprintf("Equipped armor %s", armor), nil
+
+	case shield != "":
+		character.Equipment.Shield = shield
+		return fmt.Sprintf("Equipped shield %s", shield), nil
+
+	default:
+		return "", fmt.Errorf("no equipment provided")
+	}
+}
diff --git a/service/equipment_service_test.go b/service/equipment_service_test.go
new file mode 100644
index 0000000..bdce8aa
--- /dev/null
+++ b/service/equipment_service_test.go
@@ -0,0 +1,103 @@
+package service
+
+import (
+	"strings"
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestEquipmentService_EquipWeaponSuccess(t *testing.T) {
+	svc := NewEquipmentService()
+	char := &domain.Character{
+		Equipment: domain.Equipment{
+			Weapon: map[string]string{},
+		},
+	}
+
+	msg, err := svc.Equip(char, "shortsword", "main hand", "", "")
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	expected := "Equipped weapon shortsword to main hand"
+	if msg != expected {
+		t.Errorf("expected %q, got %q", expected, msg)
+	}
+
+	if char.Equipment.Weapon["main hand"] != "shortsword" {
+		t.Errorf("weapon not actually equipped")
+	}
+}
+
+func TestEquipmentService_EquipWeaponSlotOccupied(t *testing.T) {
+	svc := NewEquipmentService()
+	char := &domain.Character{
+		Equipment: domain.Equipment{
+			Weapon: map[string]string{"off hand": "dagger"},
+		},
+	}
+
+	_, err := svc.Equip(char, "shortsword", "off hand", "", "")
+	if err == nil {
+		t.Fatal("expected error but got none")
+	}
+
+	expected := "off hand already occupied"
+	if !strings.Contains(err.Error(), expected) {
+		t.Errorf("expected error %q, got %q", expected, err.Error())
+	}
+}
+
+func TestEquipmentService_EquipArmor(t *testing.T) {
+	svc := NewEquipmentService()
+	char := &domain.Character{}
+
+	msg, err := svc.Equip(char, "", "", "chain shirt", "")
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	expected := "Equipped armor chain shirt"
+	if msg != expected {
+		t.Errorf("expected %q, got %q", expected, msg)
+	}
+
+	if char.Equipment.Armor != "chain shirt" {
+		t.Errorf("armor not equipped")
+	}
+}
+
+func TestEquipmentService_EquipShield(t *testing.T) {
+	svc := NewEquipmentService()
+	char := &domain.Character{}
+
+	msg, err := svc.Equip(char, "", "", "", "shield")
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	expected := "Equipped shield shield"
+	if msg != expected {
+		t.Errorf("expected %q, got %q", expected, msg)
+	}
+
+	if char.Equipment.Shield != "shield" {
+		t.Errorf("shield not equipped")
+	}
+}
+
+func TestEquipmentService_NoInput(t *testing.T) {
+	svc := NewEquipmentService()
+	char := &domain.Character{}
+
+	_, err := svc.Equip(char, "", "", "", "")
+	if err == nil {
+		t.Fatal("expected error for no input")
+	}
+
+	expected := "no equipment provided"
+	if !strings.Contains(err.Error(), expected) {
+		t.Errorf("expected error to contain %q, got %q", expected, err.Error())
+	}
+}
diff --git a/service/passive_perception.go b/service/passive_perception.go
deleted file mode 100644
index b440cd3..0000000
--- a/service/passive_perception.go
+++ /dev/null
@@ -1,15 +0,0 @@
-package service
-
-import "github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
-
-func CalculatePassivePerception(c *domain.Character) int {
-	base := 10 + c.Stats.WisMod
-
-	for _, skill := range c.Skills.Skills {
-		if skill == "perception" {
-			base += c.Proficiency
-			break
-		}
-	}
-	return base
-}
diff --git a/service/sanitize_keys.go b/service/sanitize_keys.go
index 4e6ad74..be289b6 100644
--- a/service/sanitize_keys.go
+++ b/service/sanitize_keys.go
@@ -17,21 +17,3 @@ func SanitizeApiKey(name string) string {
 	key = strings.TrimSpace(key)
 	return key
 }
-
-func SanitizeLocalKey(name string) string {
-	key := strings.ToLower(name)
-	key = strings.ReplaceAll(key, "'", "")
-	key = strings.ReplaceAll(key, "â€™", "")
-	key = strings.ReplaceAll(key, "(", "")
-	key = strings.ReplaceAll(key, ")", "")
-	key = strings.ReplaceAll(key, ",", "")
-	key = strings.ReplaceAll(key, "/", "-")
-	key = strings.ReplaceAll(key, ":", "")
-	key = strings.ReplaceAll(key, ".", "")
-	key = strings.ReplaceAll(key, " ", "-")
-	key = strings.ReplaceAll(key, " ", "-")
-	key = strings.TrimSuffix(key, "-armor")
-	key = strings.TrimSuffix(key, " armor")
-	key = strings.TrimSpace(key)
-	return key
-}
diff --git a/service/spell_service.go b/service/spell_service.go
new file mode 100644
index 0000000..76f8eae
--- /dev/null
+++ b/service/spell_service.go
@@ -0,0 +1,86 @@
+package service
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+type SpellService struct{}
+
+func NewSpellService() *SpellService {
+	return &SpellService{}
+}
+
+func (s *SpellService) LearnSpell(c *domain.Character, spellName string) (string, error) {
+	if c.Spellcasting == nil || !c.Spellcasting.CanCast {
+		return "", fmt.Errorf("this class can't cast spells")
+	}
+
+	for _, s := range c.Spellcasting.LearnedSpells {
+		if strings.EqualFold(s, spellName) {
+			return "", fmt.Errorf("%s already learned", spellName)
+		}
+	}
+
+	if c.Spellcasting.PreparedMode {
+		return "", fmt.Errorf("this class prepares spells and can't learn them")
+	}
+
+	level, err := GetSpellLevel(spellName)
+	if err != nil {
+		return "", err
+	}
+
+	if !IsSpellForClass(spellName, c.Class) {
+		return "", fmt.Errorf("%s cannot learn %s", c.Class, spellName)
+	}
+
+	if level > 0 {
+		if slots, ok := c.Spellcasting.Slots[level]; !ok || slots == 0 {
+			return "", fmt.Errorf("the spell has higher level than the available spell slots")
+		}
+	}
+
+	c.Spellcasting.LearnedMode = true
+	c.Spellcasting.LearnedSpells = append(c.Spellcasting.LearnedSpells, spellName)
+
+	return fmt.Sprintf("Learned spell %s", spellName), nil
+}
+
+func (s *SpellService) PrepareSpell(c *domain.Character, spellName string) (string, error) {
+	if c.Spellcasting == nil || !c.Spellcasting.CanCast {
+		return "", fmt.Errorf("this class can't cast spells")
+	}
+
+	for _, s := range c.Spellcasting.PreparedSpells {
+		if strings.EqualFold(s, spellName) {
+			return "", fmt.Errorf("%s already prepared", spellName)
+		}
+	}
+
+	if c.Spellcasting.LearnedMode {
+		return "", fmt.Errorf("this class learns spells and can't prepare them")
+	}
+
+	level, err := GetSpellLevel(spellName)
+	if err != nil {
+		return "", err
+	}
+
+	if !IsSpellForClass(spellName, c.Class) {
+		return "", fmt.Errorf("%s cannot prepare %s", c.Class, spellName)
+	}
+
+	if level > 0 {
+		if slots, ok := c.Spellcasting.Slots[level]; !ok || slots == 0 {
+			return "", fmt.Errorf("the spell has higher level than the available spell slots")
+		}
+	}
+
+	c.Spellcasting.PreparedMode = true
+	c.Spellcasting.PreparedSpells = append(c.Spellcasting.PreparedSpells, spellName)
+
+	return fmt.Sprintf("Prepared spell %s", spellName), nil
+}
diff --git a/service/spell_service_test.go b/service/spell_service_test.go
new file mode 100644
index 0000000..97687f9
--- /dev/null
+++ b/service/spell_service_test.go
@@ -0,0 +1,77 @@
+package service
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func setupCaster() *domain.Character {
+	return &domain.Character{
+		Class: "wizard",
+		Spellcasting: &domain.Spellcasting{
+			CanCast:        true,
+			Slots:          map[int]int{1: 2},
+			MaxSlots:       map[int]int{1: 2},
+			LearnedSpells:  []string{},
+			PreparedSpells: []string{},
+		},
+	}
+}
+
+func TestLearnSpell_Success(t *testing.T) {
+	SpellDB = map[string]SpellMetadata{
+		"light": {Level: 0, Classes: []string{"wizard", "cleric"}},
+	}
+	c := setupCaster()
+	svc := NewSpellService()
+
+	msg, err := svc.LearnSpell(c, "light")
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+	if msg != "Learned spell light" {
+		t.Errorf("got: %s", msg)
+	}
+	if len(c.Spellcasting.LearnedSpells) != 1 {
+		t.Errorf("spell not stored")
+	}
+}
+
+func TestLearnSpell_AlreadyKnown(t *testing.T) {
+	c := setupCaster()
+	c.Spellcasting.LearnedSpells = []string{"light"}
+
+	svc := NewSpellService()
+	_, err := svc.LearnSpell(c, "light")
+	if err == nil {
+		t.Fatal("expected error but got nil")
+	}
+}
+
+func TestPrepareSpell_Success(t *testing.T) {
+	c := setupCaster()
+	svc := NewSpellService()
+
+	msg, err := svc.PrepareSpell(c, "light")
+	if err != nil {
+		t.Fatalf("unexpected: %v", err)
+	}
+	if msg != "Prepared spell light" {
+		t.Errorf("got: %s", msg)
+	}
+	if len(c.Spellcasting.PreparedSpells) != 1 {
+		t.Errorf("spell not stored")
+	}
+}
+
+func TestPrepareSpell_AlreadyPrepared(t *testing.T) {
+	c := setupCaster()
+	c.Spellcasting.PreparedSpells = []string{"light"}
+
+	svc := NewSpellService()
+	_, err := svc.PrepareSpell(c, "light")
+	if err == nil {
+		t.Fatal("expected error")
+	}
+}
diff --git a/service/spellbook_test.go b/service/spellbook_test.go
new file mode 100644
index 0000000..bf6d2f5
--- /dev/null
+++ b/service/spellbook_test.go
@@ -0,0 +1,82 @@
+package service
+
+import (
+	"os"
+	"testing"
+)
+
+func TestSplitAndTrim(t *testing.T) {
+	in := "Wizard, Sorcerer ,  Cleric"
+	want := []string{"wizard", "sorcerer", "cleric"}
+
+	got := splitAndTrim(in)
+
+	if len(got) != len(want) {
+		t.Fatalf("expected %d items, got %d", len(want), len(got))
+	}
+
+	for i := range want {
+		if got[i] != want[i] {
+			t.Errorf("expected %s, got %s", want[i], got[i])
+		}
+	}
+}
+
+func TestGetSpellLevel(t *testing.T) {
+	SpellDB = map[string]SpellMetadata{
+		"fire bolt": {Level: 0},
+	}
+
+	level, err := GetSpellLevel("fire bolt")
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+	if level != 0 {
+		t.Errorf("expected level 0, got %d", level)
+	}
+
+	_, err = GetSpellLevel("unknown spell")
+	if err == nil {
+		t.Fatal("expected error for unknown spell")
+	}
+}
+
+func TestIsSpellForClass(t *testing.T) {
+	SpellDB = map[string]SpellMetadata{
+		"cure wounds": {Level: 1, Classes: []string{"cleric", "druid"}},
+	}
+
+	if !IsSpellForClass("cure wounds", "Cleric") {
+		t.Error("expected cleric to be allowed")
+	}
+
+	if IsSpellForClass("cure wounds", "wizard") {
+		t.Error("expected wizard NOT to be allowed")
+	}
+}
+
+func TestLoadSpellsCSV(t *testing.T) {
+	content := `name,level,class
+Acid Splash,0,"Sorcerer,Wizard"
+Cure Wounds,1,"Cleric,Druid"
+`
+	tmp := "test_spells.csv"
+	os.WriteFile(tmp, []byte(content), 0644)
+	defer os.Remove(tmp)
+
+	err := LoadSpellsCSV(tmp)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	spell, ok := SpellDB["acid splash"]
+	if !ok {
+		t.Fatal("expected acid splash entry")
+	}
+	if spell.Level != 0 {
+		t.Errorf("expected level 0, got %d", spell.Level)
+	}
+	if len(spell.Classes) == 0 || spell.Classes[0] != "sorcerer" {
+		t.Errorf("expected sorcerer in class list")
+	}
+}
diff --git a/service/spellcasting.go b/service/spellcasting.go
index cc12acc..5311936 100644
--- a/service/spellcasting.go
+++ b/service/spellcasting.go
@@ -79,8 +79,8 @@ var pactCasterSlots = map[int]map[int]int{
 
 func GetSlotsForClassLevel(class string, level int) (map[int]int, string, error) {
 	classKey := strings.ToLower(strings.TrimSpace(class))
-	casterType, ok := domain.SpellcastingType[classKey]
-	if !ok {
+	casterType := domain.GetSpellcastingType(classKey)
+	if casterType == "" {
 		return nil, "", fmt.Errorf("class %s is not a spellcaster", class)
 	}
 
@@ -97,7 +97,6 @@ func GetSlotsForClassLevel(class string, level int) (map[int]int, string, error)
 		if m, ok := pactCasterSlots[level]; ok {
 			return copyIntMap(m), "pact", nil
 		}
-	//default aka not spellcaster
 	default:
 		return nil, "", fmt.Errorf("no slot table for class %s", class)
 	}
diff --git a/service/spellcasting_test.go b/service/spellcasting_test.go
new file mode 100644
index 0000000..15a604e
--- /dev/null
+++ b/service/spellcasting_test.go
@@ -0,0 +1,145 @@
+package service
+
+import (
+	"testing"
+
+	"github.com/DanielBartha/MPP-DnD-Character-Gen/domain"
+)
+
+func TestGetSlotsForClassLevel_FullCaster(t *testing.T) {
+	slots, casterType, err := GetSlotsForClassLevel("Wizard", 1)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+	if casterType != "full" {
+		t.Errorf("expected full caster, got %s", casterType)
+	}
+	if slots[1] != 2 {
+		t.Errorf("expected 2 level-1 slots, got %d", slots[1])
+	}
+}
+
+func TestGetSlotsForClassLevel_HalfCaster(t *testing.T) {
+	slots, casterType, err := GetSlotsForClassLevel("Paladin", 5)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+	if casterType != "half" {
+		t.Errorf("expected half caster, got %s", casterType)
+	}
+	if slots[1] != 4 || slots[2] != 2 {
+		t.Errorf("unexpected slot table for paladin lvl 5: %#v", slots)
+	}
+}
+
+func TestGetSlotsForClassLevel_PactCaster(t *testing.T) {
+	slots, casterType, err := GetSlotsForClassLevel("Warlock", 3)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+	if casterType != "pact" {
+		t.Errorf("expected pact caster, got %s", casterType)
+	}
+	if slots[2] != 2 {
+		t.Errorf("expected 2 lvl-2 slots, got %d", slots[2])
+	}
+}
+
+func TestGetSlotsForClassLevel_NonCaster(t *testing.T) {
+	_, _, err := GetSlotsForClassLevel("Fighter", 1)
+	if err == nil {
+		t.Fatal("expected error for non-caster fighter")
+	}
+}
+
+func TestGetSlotsForClassLevel_InvalidLevel(t *testing.T) {
+	_, _, err := GetSlotsForClassLevel("Wizard", 99)
+	if err == nil {
+		t.Fatal("expected error for invalid level")
+	}
+}
+
+func TestGetSpellcastingAbility(t *testing.T) {
+	tests := map[string]string{
+		"wizard":   "intelligence",
+		"cleric":   "wisdom",
+		"sorcerer": "charisma",
+		"fighter":  "",
+	}
+
+	for class, want := range tests {
+		got := GetSpellcastingAbility(class)
+		if got != want {
+			t.Errorf("class %s: want %s, got %s", class, want, got)
+		}
+	}
+}
+
+func TestInitSpellcasting_FullCaster(t *testing.T) {
+	svc := &CharacterService{}
+	c := &domain.Character{
+		Class:       "Wizard",
+		Level:       1,
+		Stats:       domain.Stats{IntelMod: 3},
+		Proficiency: 2,
+	}
+
+	svc.InitSpellcasting(c)
+
+	if !c.Spellcasting.CanCast {
+		t.Fatal("wizard should be able to cast")
+	}
+	if c.Spellcasting.SpellSaveDC != 8+2+3 {
+		t.Errorf("wrong DC: %d", c.Spellcasting.SpellSaveDC)
+	}
+	if c.Spellcasting.CantripsKnown != 3 {
+		t.Errorf("expected 3 cantrips lvl1 wizard, got %d", c.Spellcasting.CantripsKnown)
+	}
+}
+
+func TestInitSpellcasting_HalfCaster_Level1_NoCast(t *testing.T) {
+	svc := &CharacterService{}
+	c := &domain.Character{
+		Class: "Paladin",
+		Level: 1,
+	}
+
+	svc.InitSpellcasting(c)
+
+	if c.Spellcasting.CanCast {
+		t.Error("paladin lvl1 should NOT cast")
+	}
+}
+
+func TestInitSpellcasting_PactCaster(t *testing.T) {
+	svc := &CharacterService{}
+	c := &domain.Character{
+		Class:       "Warlock",
+		Level:       2,
+		Stats:       domain.Stats{ChaMod: 2},
+		Proficiency: 2,
+	}
+
+	svc.InitSpellcasting(c)
+
+	if !c.Spellcasting.CanCast {
+		t.Fatal("warlock lvl2 should cast")
+	}
+	if c.Spellcasting.Slots[1] != 2 {
+		t.Errorf("expected 2 lvl-1 pact slots, got %d", c.Spellcasting.Slots[1])
+	}
+	if c.Spellcasting.CantripsKnown != 2 {
+		t.Errorf("warlock lvl2 should know 2 cantrips")
+	}
+}
+
+func TestCopyIntMap(t *testing.T) {
+	orig := map[int]int{1: 2}
+	copy := copyIntMap(orig)
+
+	orig[1] = 99
+
+	if copy[1] == 99 {
+		t.Fatal("copy changed when original changed (map not copied)")
+	}
+}
